"""This is an automatically generated stub for `legacy.capnp`."""
from __future__ import annotations

from contextlib import contextmanager
from io import BufferedWriter
from typing import Iterator, Literal, Sequence, overload


class LogRotate:
    segmentNum: int
    path: str
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[LogRotateReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> LogRotateReader: ...
    @staticmethod
    def new_message() -> LogRotateBuilder: ...
    def to_dict(self) -> dict: ...
class LogRotateReader(LogRotate):
    def as_builder(self) -> LogRotateBuilder: ...
class LogRotateBuilder(LogRotate):
    @staticmethod
    def from_dict(dictionary: dict) -> LogRotateBuilder: ...
    def copy(self) -> LogRotateBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> LogRotateReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class LiveUI:
    rearViewCam: bool
    alertText1: str
    alertText2: str
    awarenessStatus: float
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[LiveUIReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> LiveUIReader: ...
    @staticmethod
    def new_message() -> LiveUIBuilder: ...
    def to_dict(self) -> dict: ...
class LiveUIReader(LiveUI):
    def as_builder(self) -> LiveUIBuilder: ...
class LiveUIBuilder(LiveUI):
    @staticmethod
    def from_dict(dictionary: dict) -> LiveUIBuilder: ...
    def copy(self) -> LiveUIBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> LiveUIReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class UiLayoutState:
    App = Literal["home", "music", "nav", "settings", "none"]
    activeApp: UiLayoutState.App
    sidebarCollapsed: bool
    mapEnabled: bool
    mockEngaged: bool
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[UiLayoutStateReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> UiLayoutStateReader: ...
    @staticmethod
    def new_message() -> UiLayoutStateBuilder: ...
    def to_dict(self) -> dict: ...
class UiLayoutStateReader(UiLayoutState):
    def as_builder(self) -> UiLayoutStateBuilder: ...
class UiLayoutStateBuilder(UiLayoutState):
    @staticmethod
    def from_dict(dictionary: dict) -> UiLayoutStateBuilder: ...
    def copy(self) -> UiLayoutStateBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> UiLayoutStateReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class OrbslamCorrection:
    correctionMonoTime: int
    prePositionECEF: Sequence[float]
    postPositionECEF: Sequence[float]
    prePoseQuatECEF: Sequence[float]
    postPoseQuatECEF: Sequence[float]
    numInliers: int
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[OrbslamCorrectionReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> OrbslamCorrectionReader: ...
    @staticmethod
    def new_message() -> OrbslamCorrectionBuilder: ...
    def to_dict(self) -> dict: ...
class OrbslamCorrectionReader(OrbslamCorrection):
    def as_builder(self) -> OrbslamCorrectionBuilder: ...
class OrbslamCorrectionBuilder(OrbslamCorrection):
    @staticmethod
    def from_dict(dictionary: dict) -> OrbslamCorrectionBuilder: ...
    def copy(self) -> OrbslamCorrectionBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> OrbslamCorrectionReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class EthernetPacket:
    pkt: bytes
    ts: float
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[EthernetPacketReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> EthernetPacketReader: ...
    @staticmethod
    def new_message() -> EthernetPacketBuilder: ...
    def to_dict(self) -> dict: ...
class EthernetPacketReader(EthernetPacket):
    def as_builder(self) -> EthernetPacketBuilder: ...
class EthernetPacketBuilder(EthernetPacket):
    @staticmethod
    def from_dict(dictionary: dict) -> EthernetPacketBuilder: ...
    def copy(self) -> EthernetPacketBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> EthernetPacketReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class CellInfo:
    timestamp: int
    repr: str
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[CellInfoReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> CellInfoReader: ...
    @staticmethod
    def new_message() -> CellInfoBuilder: ...
    def to_dict(self) -> dict: ...
class CellInfoReader(CellInfo):
    def as_builder(self) -> CellInfoBuilder: ...
class CellInfoBuilder(CellInfo):
    @staticmethod
    def from_dict(dictionary: dict) -> CellInfoBuilder: ...
    def copy(self) -> CellInfoBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> CellInfoReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class WifiScan:
    ChannelWidth = Literal["w20Mhz", "w40Mhz", "w80Mhz", "w160Mhz", "w80Plus80Mhz"]
    bssid: str
    ssid: str
    capabilities: str
    frequency: int
    level: int
    timestamp: int
    centerFreq0: int
    centerFreq1: int
    channelWidth: WifiScan.ChannelWidth
    operatorFriendlyName: str
    venueName: str
    is80211mcResponder: bool
    passpoint: bool
    distanceCm: int
    distanceSdCm: int
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[WifiScanReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> WifiScanReader: ...
    @staticmethod
    def new_message() -> WifiScanBuilder: ...
    def to_dict(self) -> dict: ...
class WifiScanReader(WifiScan):
    def as_builder(self) -> WifiScanBuilder: ...
class WifiScanBuilder(WifiScan):
    @staticmethod
    def from_dict(dictionary: dict) -> WifiScanBuilder: ...
    def copy(self) -> WifiScanBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> WifiScanReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class LiveEventData:
    name: str
    value: int
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[LiveEventDataReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> LiveEventDataReader: ...
    @staticmethod
    def new_message() -> LiveEventDataBuilder: ...
    def to_dict(self) -> dict: ...
class LiveEventDataReader(LiveEventData):
    def as_builder(self) -> LiveEventDataBuilder: ...
class LiveEventDataBuilder(LiveEventData):
    @staticmethod
    def from_dict(dictionary: dict) -> LiveEventDataBuilder: ...
    def copy(self) -> LiveEventDataBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> LiveEventDataReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class ModelData:
    class PathData:
        points: Sequence[float]
        prob: float
        std: float
        stds: Sequence[float]
        poly: Sequence[float]
        validLen: float
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[ModelData.PathDataReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> ModelData.PathDataReader: ...
        @staticmethod
        def new_message() -> ModelData.PathDataBuilder: ...
        def to_dict(self) -> dict: ...
    class PathDataReader(ModelData.PathData):
        def as_builder(self) -> ModelData.PathDataBuilder: ...
    class PathDataBuilder(ModelData.PathData):
        @staticmethod
        def from_dict(dictionary: dict) -> ModelData.PathDataBuilder: ...
        def copy(self) -> ModelData.PathDataBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> ModelData.PathDataReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    class LeadData:
        dist: float
        prob: float
        std: float
        relVel: float
        relVelStd: float
        relY: float
        relYStd: float
        relA: float
        relAStd: float
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[ModelData.LeadDataReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> ModelData.LeadDataReader: ...
        @staticmethod
        def new_message() -> ModelData.LeadDataBuilder: ...
        def to_dict(self) -> dict: ...
    class LeadDataReader(ModelData.LeadData):
        def as_builder(self) -> ModelData.LeadDataBuilder: ...
    class LeadDataBuilder(ModelData.LeadData):
        @staticmethod
        def from_dict(dictionary: dict) -> ModelData.LeadDataBuilder: ...
        def copy(self) -> ModelData.LeadDataBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> ModelData.LeadDataReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    class ModelSettings:
        bigBoxX: int
        bigBoxY: int
        bigBoxWidth: int
        bigBoxHeight: int
        boxProjection: Sequence[float]
        yuvCorrection: Sequence[float]
        inputTransform: Sequence[float]
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[ModelData.ModelSettingsReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> ModelData.ModelSettingsReader: ...
        @staticmethod
        def new_message() -> ModelData.ModelSettingsBuilder: ...
        def to_dict(self) -> dict: ...
    class ModelSettingsReader(ModelData.ModelSettings):
        def as_builder(self) -> ModelData.ModelSettingsBuilder: ...
    class ModelSettingsBuilder(ModelData.ModelSettings):
        @staticmethod
        def from_dict(dictionary: dict) -> ModelData.ModelSettingsBuilder: ...
        def copy(self) -> ModelData.ModelSettingsBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> ModelData.ModelSettingsReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    class MetaData:
        engagedProb: float
        desirePrediction: Sequence[float]
        brakeDisengageProb: float
        gasDisengageProb: float
        steerOverrideProb: float
        desireState: Sequence[float]
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[ModelData.MetaDataReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> ModelData.MetaDataReader: ...
        @staticmethod
        def new_message() -> ModelData.MetaDataBuilder: ...
        def to_dict(self) -> dict: ...
    class MetaDataReader(ModelData.MetaData):
        def as_builder(self) -> ModelData.MetaDataBuilder: ...
    class MetaDataBuilder(ModelData.MetaData):
        @staticmethod
        def from_dict(dictionary: dict) -> ModelData.MetaDataBuilder: ...
        def copy(self) -> ModelData.MetaDataBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> ModelData.MetaDataReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    class LongitudinalData:
        speeds: Sequence[float]
        accelerations: Sequence[float]
        distances: Sequence[float]
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[ModelData.LongitudinalDataReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> ModelData.LongitudinalDataReader: ...
        @staticmethod
        def new_message() -> ModelData.LongitudinalDataBuilder: ...
        def to_dict(self) -> dict: ...
    class LongitudinalDataReader(ModelData.LongitudinalData):
        def as_builder(self) -> ModelData.LongitudinalDataBuilder: ...
    class LongitudinalDataBuilder(ModelData.LongitudinalData):
        @staticmethod
        def from_dict(dictionary: dict) -> ModelData.LongitudinalDataBuilder: ...
        def copy(self) -> ModelData.LongitudinalDataBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> ModelData.LongitudinalDataReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    frameId: int
    path: ModelData.PathData | ModelData.PathDataBuilder | ModelData.PathDataReader
    leftLane: ModelData.PathData | ModelData.PathDataBuilder | ModelData.PathDataReader
    rightLane: ModelData.PathData | ModelData.PathDataBuilder | ModelData.PathDataReader
    lead: ModelData.LeadData | ModelData.LeadDataBuilder | ModelData.LeadDataReader
    settings: ModelData.ModelSettings | ModelData.ModelSettingsBuilder | ModelData.ModelSettingsReader
    freePath: Sequence[float]
    leadFuture: ModelData.LeadData | ModelData.LeadDataBuilder | ModelData.LeadDataReader
    speed: Sequence[float]
    timestampEof: int
    meta: ModelData.MetaData | ModelData.MetaDataBuilder | ModelData.MetaDataReader
    longitudinal: ModelData.LongitudinalData | ModelData.LongitudinalDataBuilder | ModelData.LongitudinalDataReader
    frameAge: int
    frameDropPerc: float
    modelExecutionTime: float
    rawPred: bytes
    gpuExecutionTime: float
    @overload
    def init(self, name: Literal["path"]) -> ModelData.PathData: ...
    @overload
    def init(self, name: Literal["leftLane"]) -> ModelData.PathData: ...
    @overload
    def init(self, name: Literal["rightLane"]) -> ModelData.PathData: ...
    @overload
    def init(self, name: Literal["lead"]) -> ModelData.LeadData: ...
    @overload
    def init(self, name: Literal["settings"]) -> ModelData.ModelSettings: ...
    @overload
    def init(self, name: Literal["leadFuture"]) -> ModelData.LeadData: ...
    @overload
    def init(self, name: Literal["meta"]) -> ModelData.MetaData: ...
    @overload
    def init(self, name: Literal["longitudinal"]) -> ModelData.LongitudinalData: ...
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[ModelDataReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> ModelDataReader: ...
    @staticmethod
    def new_message() -> ModelDataBuilder: ...
    def to_dict(self) -> dict: ...
class ModelDataReader(ModelData):
    path: ModelData.PathDataReader
    leftLane: ModelData.PathDataReader
    rightLane: ModelData.PathDataReader
    lead: ModelData.LeadDataReader
    settings: ModelData.ModelSettingsReader
    leadFuture: ModelData.LeadDataReader
    meta: ModelData.MetaDataReader
    longitudinal: ModelData.LongitudinalDataReader
    def as_builder(self) -> ModelDataBuilder: ...
class ModelDataBuilder(ModelData):
    path: ModelData.PathData | ModelData.PathDataBuilder | ModelData.PathDataReader
    leftLane: ModelData.PathData | ModelData.PathDataBuilder | ModelData.PathDataReader
    rightLane: ModelData.PathData | ModelData.PathDataBuilder | ModelData.PathDataReader
    lead: ModelData.LeadData | ModelData.LeadDataBuilder | ModelData.LeadDataReader
    settings: ModelData.ModelSettings | ModelData.ModelSettingsBuilder | ModelData.ModelSettingsReader
    leadFuture: ModelData.LeadData | ModelData.LeadDataBuilder | ModelData.LeadDataReader
    meta: ModelData.MetaData | ModelData.MetaDataBuilder | ModelData.MetaDataReader
    longitudinal: ModelData.LongitudinalData | ModelData.LongitudinalDataBuilder | ModelData.LongitudinalDataReader
    @staticmethod
    def from_dict(dictionary: dict) -> ModelDataBuilder: ...
    def copy(self) -> ModelDataBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> ModelDataReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class ECEFPoint:
    x: float
    y: float
    z: float
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[ECEFPointReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> ECEFPointReader: ...
    @staticmethod
    def new_message() -> ECEFPointBuilder: ...
    def to_dict(self) -> dict: ...
class ECEFPointReader(ECEFPoint):
    def as_builder(self) -> ECEFPointBuilder: ...
class ECEFPointBuilder(ECEFPoint):
    @staticmethod
    def from_dict(dictionary: dict) -> ECEFPointBuilder: ...
    def copy(self) -> ECEFPointBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> ECEFPointReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class ECEFPointDEPRECATED:
    x: float
    y: float
    z: float
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[ECEFPointDEPRECATEDReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> ECEFPointDEPRECATEDReader: ...
    @staticmethod
    def new_message() -> ECEFPointDEPRECATEDBuilder: ...
    def to_dict(self) -> dict: ...
class ECEFPointDEPRECATEDReader(ECEFPointDEPRECATED):
    def as_builder(self) -> ECEFPointDEPRECATEDBuilder: ...
class ECEFPointDEPRECATEDBuilder(ECEFPointDEPRECATED):
    @staticmethod
    def from_dict(dictionary: dict) -> ECEFPointDEPRECATEDBuilder: ...
    def copy(self) -> ECEFPointDEPRECATEDBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> ECEFPointDEPRECATEDReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class GPSPlannerPoints:
    curPosDEPRECATED: ECEFPointDEPRECATED | ECEFPointDEPRECATEDBuilder | ECEFPointDEPRECATEDReader
    pointsDEPRECATED: Sequence[ECEFPointDEPRECATED | ECEFPointDEPRECATEDBuilder | ECEFPointDEPRECATEDReader]
    valid: bool
    trackName: str
    speedLimit: float
    accelTarget: float
    curPos: ECEFPoint | ECEFPointBuilder | ECEFPointReader
    points: Sequence[ECEFPoint | ECEFPointBuilder | ECEFPointReader]
    @overload
    def init(self, name: Literal["curPosDEPRECATED"]) -> ECEFPointDEPRECATED: ...
    @overload
    def init(self, name: Literal["curPos"]) -> ECEFPoint: ...
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[GPSPlannerPointsReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> GPSPlannerPointsReader: ...
    @staticmethod
    def new_message() -> GPSPlannerPointsBuilder: ...
    def to_dict(self) -> dict: ...
class GPSPlannerPointsReader(GPSPlannerPoints):
    curPosDEPRECATED: ECEFPointDEPRECATEDReader
    pointsDEPRECATED: Sequence[ECEFPointDEPRECATEDReader]
    curPos: ECEFPointReader
    points: Sequence[ECEFPointReader]
    def as_builder(self) -> GPSPlannerPointsBuilder: ...
class GPSPlannerPointsBuilder(GPSPlannerPoints):
    curPosDEPRECATED: ECEFPointDEPRECATED | ECEFPointDEPRECATEDBuilder | ECEFPointDEPRECATEDReader
    pointsDEPRECATED: Sequence[ECEFPointDEPRECATED | ECEFPointDEPRECATEDBuilder | ECEFPointDEPRECATEDReader]
    curPos: ECEFPoint | ECEFPointBuilder | ECEFPointReader
    points: Sequence[ECEFPoint | ECEFPointBuilder | ECEFPointReader]
    @staticmethod
    def from_dict(dictionary: dict) -> GPSPlannerPointsBuilder: ...
    def copy(self) -> GPSPlannerPointsBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> GPSPlannerPointsReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class GPSPlannerPlan:
    valid: bool
    poly: Sequence[float]
    trackName: str
    speed: float
    acceleration: float
    pointsDEPRECATED: Sequence[ECEFPointDEPRECATED | ECEFPointDEPRECATEDBuilder | ECEFPointDEPRECATEDReader]
    points: Sequence[ECEFPoint | ECEFPointBuilder | ECEFPointReader]
    xLookahead: float
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[GPSPlannerPlanReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> GPSPlannerPlanReader: ...
    @staticmethod
    def new_message() -> GPSPlannerPlanBuilder: ...
    def to_dict(self) -> dict: ...
class GPSPlannerPlanReader(GPSPlannerPlan):
    pointsDEPRECATED: Sequence[ECEFPointDEPRECATEDReader]
    points: Sequence[ECEFPointReader]
    def as_builder(self) -> GPSPlannerPlanBuilder: ...
class GPSPlannerPlanBuilder(GPSPlannerPlan):
    pointsDEPRECATED: Sequence[ECEFPointDEPRECATED | ECEFPointDEPRECATEDBuilder | ECEFPointDEPRECATEDReader]
    points: Sequence[ECEFPoint | ECEFPointBuilder | ECEFPointReader]
    @staticmethod
    def from_dict(dictionary: dict) -> GPSPlannerPlanBuilder: ...
    def copy(self) -> GPSPlannerPlanBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> GPSPlannerPlanReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class UiNavigationEvent:
    Type = Literal["none", "laneChangeLeft", "laneChangeRight", "mergeLeft", "mergeRight", "turnLeft", "turnRight"]
    Status = Literal["none", "passive", "approaching", "active"]
    type: UiNavigationEvent.Type
    status: UiNavigationEvent.Status
    distanceTo: float
    endRoadPointDEPRECATED: ECEFPointDEPRECATED | ECEFPointDEPRECATEDBuilder | ECEFPointDEPRECATEDReader
    endRoadPoint: ECEFPoint | ECEFPointBuilder | ECEFPointReader
    @overload
    def init(self, name: Literal["endRoadPointDEPRECATED"]) -> ECEFPointDEPRECATED: ...
    @overload
    def init(self, name: Literal["endRoadPoint"]) -> ECEFPoint: ...
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[UiNavigationEventReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> UiNavigationEventReader: ...
    @staticmethod
    def new_message() -> UiNavigationEventBuilder: ...
    def to_dict(self) -> dict: ...
class UiNavigationEventReader(UiNavigationEvent):
    endRoadPointDEPRECATED: ECEFPointDEPRECATEDReader
    endRoadPoint: ECEFPointReader
    def as_builder(self) -> UiNavigationEventBuilder: ...
class UiNavigationEventBuilder(UiNavigationEvent):
    endRoadPointDEPRECATED: ECEFPointDEPRECATED | ECEFPointDEPRECATEDBuilder | ECEFPointDEPRECATEDReader
    endRoadPoint: ECEFPoint | ECEFPointBuilder | ECEFPointReader
    @staticmethod
    def from_dict(dictionary: dict) -> UiNavigationEventBuilder: ...
    def copy(self) -> UiNavigationEventBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> UiNavigationEventReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class LiveLocationData:
    class Accuracy:
        pNEDError: Sequence[float]
        vNEDError: Sequence[float]
        rollError: float
        pitchError: float
        headingError: float
        ellipsoidSemiMajorError: float
        ellipsoidSemiMinorError: float
        ellipsoidOrientationError: float
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[LiveLocationData.AccuracyReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> LiveLocationData.AccuracyReader: ...
        @staticmethod
        def new_message() -> LiveLocationData.AccuracyBuilder: ...
        def to_dict(self) -> dict: ...
    class AccuracyReader(LiveLocationData.Accuracy):
        def as_builder(self) -> LiveLocationData.AccuracyBuilder: ...
    class AccuracyBuilder(LiveLocationData.Accuracy):
        @staticmethod
        def from_dict(dictionary: dict) -> LiveLocationData.AccuracyBuilder: ...
        def copy(self) -> LiveLocationData.AccuracyBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> LiveLocationData.AccuracyReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    SensorSource = Literal["applanix", "kalman", "orbslam", "timing", "dummy"]
    status: int
    lat: float
    lon: float
    alt: float
    speed: float
    vNED: Sequence[float]
    roll: float
    pitch: float
    heading: float
    wanderAngle: float
    trackAngle: float
    gyro: Sequence[float]
    accel: Sequence[float]
    accuracy: LiveLocationData.Accuracy | LiveLocationData.AccuracyBuilder | LiveLocationData.AccuracyReader
    source: LiveLocationData.SensorSource
    fixMonoTime: int
    gpsWeek: int
    timeOfWeek: float
    positionECEF: Sequence[float]
    poseQuatECEF: Sequence[float]
    pitchCalibration: float
    yawCalibration: float
    imuFrame: Sequence[float]
    def init(self, name: Literal["accuracy"]) -> LiveLocationData.Accuracy: ...
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[LiveLocationDataReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> LiveLocationDataReader: ...
    @staticmethod
    def new_message() -> LiveLocationDataBuilder: ...
    def to_dict(self) -> dict: ...
class LiveLocationDataReader(LiveLocationData):
    accuracy: LiveLocationData.AccuracyReader
    def as_builder(self) -> LiveLocationDataBuilder: ...
class LiveLocationDataBuilder(LiveLocationData):
    accuracy: LiveLocationData.Accuracy | LiveLocationData.AccuracyBuilder | LiveLocationData.AccuracyReader
    @staticmethod
    def from_dict(dictionary: dict) -> LiveLocationDataBuilder: ...
    def copy(self) -> LiveLocationDataBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> LiveLocationDataReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class OrbOdometry:
    startMonoTime: int
    endMonoTime: int
    f: Sequence[float]
    err: float
    inliers: int
    matches: Sequence[int]
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[OrbOdometryReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> OrbOdometryReader: ...
    @staticmethod
    def new_message() -> OrbOdometryBuilder: ...
    def to_dict(self) -> dict: ...
class OrbOdometryReader(OrbOdometry):
    def as_builder(self) -> OrbOdometryBuilder: ...
class OrbOdometryBuilder(OrbOdometry):
    @staticmethod
    def from_dict(dictionary: dict) -> OrbOdometryBuilder: ...
    def copy(self) -> OrbOdometryBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> OrbOdometryReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class OrbFeatures:
    timestampEof: int
    xs: Sequence[float]
    ys: Sequence[float]
    descriptors: bytes
    octaves: Sequence[int]
    timestampLastEof: int
    matches: Sequence[int]
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[OrbFeaturesReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> OrbFeaturesReader: ...
    @staticmethod
    def new_message() -> OrbFeaturesBuilder: ...
    def to_dict(self) -> dict: ...
class OrbFeaturesReader(OrbFeatures):
    def as_builder(self) -> OrbFeaturesBuilder: ...
class OrbFeaturesBuilder(OrbFeatures):
    @staticmethod
    def from_dict(dictionary: dict) -> OrbFeaturesBuilder: ...
    def copy(self) -> OrbFeaturesBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> OrbFeaturesReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class OrbFeaturesSummary:
    timestampEof: int
    timestampLastEof: int
    featureCount: int
    matchCount: int
    computeNs: int
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[OrbFeaturesSummaryReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> OrbFeaturesSummaryReader: ...
    @staticmethod
    def new_message() -> OrbFeaturesSummaryBuilder: ...
    def to_dict(self) -> dict: ...
class OrbFeaturesSummaryReader(OrbFeaturesSummary):
    def as_builder(self) -> OrbFeaturesSummaryBuilder: ...
class OrbFeaturesSummaryBuilder(OrbFeaturesSummary):
    @staticmethod
    def from_dict(dictionary: dict) -> OrbFeaturesSummaryBuilder: ...
    def copy(self) -> OrbFeaturesSummaryBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> OrbFeaturesSummaryReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class OrbKeyFrame:
    id: int
    pos: ECEFPoint | ECEFPointBuilder | ECEFPointReader
    dpos: Sequence[ECEFPoint | ECEFPointBuilder | ECEFPointReader]
    descriptors: bytes
    def init(self, name: Literal["pos"]) -> ECEFPoint: ...
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[OrbKeyFrameReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> OrbKeyFrameReader: ...
    @staticmethod
    def new_message() -> OrbKeyFrameBuilder: ...
    def to_dict(self) -> dict: ...
class OrbKeyFrameReader(OrbKeyFrame):
    pos: ECEFPointReader
    dpos: Sequence[ECEFPointReader]
    def as_builder(self) -> OrbKeyFrameBuilder: ...
class OrbKeyFrameBuilder(OrbKeyFrame):
    pos: ECEFPoint | ECEFPointBuilder | ECEFPointReader
    dpos: Sequence[ECEFPoint | ECEFPointBuilder | ECEFPointReader]
    @staticmethod
    def from_dict(dictionary: dict) -> OrbKeyFrameBuilder: ...
    def copy(self) -> OrbKeyFrameBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> OrbKeyFrameReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class KalmanOdometry:
    trans: Sequence[float]
    rot: Sequence[float]
    transStd: Sequence[float]
    rotStd: Sequence[float]
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[KalmanOdometryReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> KalmanOdometryReader: ...
    @staticmethod
    def new_message() -> KalmanOdometryBuilder: ...
    def to_dict(self) -> dict: ...
class KalmanOdometryReader(KalmanOdometry):
    def as_builder(self) -> KalmanOdometryBuilder: ...
class KalmanOdometryBuilder(KalmanOdometry):
    @staticmethod
    def from_dict(dictionary: dict) -> KalmanOdometryBuilder: ...
    def copy(self) -> KalmanOdometryBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> KalmanOdometryReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class OrbObservation:
    observationMonoTime: int
    normalizedCoordinates: Sequence[float]
    locationECEF: Sequence[float]
    matchDistance: int
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[OrbObservationReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> OrbObservationReader: ...
    @staticmethod
    def new_message() -> OrbObservationBuilder: ...
    def to_dict(self) -> dict: ...
class OrbObservationReader(OrbObservation):
    def as_builder(self) -> OrbObservationBuilder: ...
class OrbObservationBuilder(OrbObservation):
    @staticmethod
    def from_dict(dictionary: dict) -> OrbObservationBuilder: ...
    def copy(self) -> OrbObservationBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> OrbObservationReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class CalibrationFeatures:
    frameId: int
    p0: Sequence[float]
    p1: Sequence[float]
    status: Sequence[int]
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[CalibrationFeaturesReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> CalibrationFeaturesReader: ...
    @staticmethod
    def new_message() -> CalibrationFeaturesBuilder: ...
    def to_dict(self) -> dict: ...
class CalibrationFeaturesReader(CalibrationFeatures):
    def as_builder(self) -> CalibrationFeaturesBuilder: ...
class CalibrationFeaturesBuilder(CalibrationFeatures):
    @staticmethod
    def from_dict(dictionary: dict) -> CalibrationFeaturesBuilder: ...
    def copy(self) -> CalibrationFeaturesBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> CalibrationFeaturesReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class NavStatus:
    class Address:
        title: str
        lat: float
        lng: float
        house: str
        address: str
        street: str
        city: str
        state: str
        country: str
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[NavStatus.AddressReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> NavStatus.AddressReader: ...
        @staticmethod
        def new_message() -> NavStatus.AddressBuilder: ...
        def to_dict(self) -> dict: ...
    class AddressReader(NavStatus.Address):
        def as_builder(self) -> NavStatus.AddressBuilder: ...
    class AddressBuilder(NavStatus.Address):
        @staticmethod
        def from_dict(dictionary: dict) -> NavStatus.AddressBuilder: ...
        def copy(self) -> NavStatus.AddressBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> NavStatus.AddressReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    isNavigating: bool
    currentAddress: NavStatus.Address | NavStatus.AddressBuilder | NavStatus.AddressReader
    def init(self, name: Literal["currentAddress"]) -> NavStatus.Address: ...
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[NavStatusReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> NavStatusReader: ...
    @staticmethod
    def new_message() -> NavStatusBuilder: ...
    def to_dict(self) -> dict: ...
class NavStatusReader(NavStatus):
    currentAddress: NavStatus.AddressReader
    def as_builder(self) -> NavStatusBuilder: ...
class NavStatusBuilder(NavStatus):
    currentAddress: NavStatus.Address | NavStatus.AddressBuilder | NavStatus.AddressReader
    @staticmethod
    def from_dict(dictionary: dict) -> NavStatusBuilder: ...
    def copy(self) -> NavStatusBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> NavStatusReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class NavUpdate:
    class LatLng:
        lat: float
        lng: float
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[NavUpdate.LatLngReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> NavUpdate.LatLngReader: ...
        @staticmethod
        def new_message() -> NavUpdate.LatLngBuilder: ...
        def to_dict(self) -> dict: ...
    class LatLngReader(NavUpdate.LatLng):
        def as_builder(self) -> NavUpdate.LatLngBuilder: ...
    class LatLngBuilder(NavUpdate.LatLng):
        @staticmethod
        def from_dict(dictionary: dict) -> NavUpdate.LatLngBuilder: ...
        def copy(self) -> NavUpdate.LatLngBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> NavUpdate.LatLngReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    class Segment:
        Instruction = Literal["turnLeft", "turnRight", "keepLeft", "keepRight", "straight", "roundaboutExitNumber", "roundaboutExit", "roundaboutTurnLeft", "unkn8", "roundaboutStraight", "unkn10", "roundaboutTurnRight", "unkn12", "roundaboutUturn", "unkn14", "arrive", "exitLeft", "exitRight", "unkn18", "uturn"]
        # from: NavUpdate.LatLng | NavUpdate.LatLngBuilder | NavUpdate.LatLngReader  # FIXME: this is not a valid python identifier
        to: NavUpdate.LatLng | NavUpdate.LatLngBuilder | NavUpdate.LatLngReader
        updateTime: int
        distance: int
        crossTime: int
        exitNo: int
        instruction: NavUpdate.Segment.Instruction
        parts: Sequence[NavUpdate.LatLng | NavUpdate.LatLngBuilder | NavUpdate.LatLngReader]
        @overload
        def init(self, name: Literal["fromm"]) -> NavUpdate.LatLng: ...
        @overload
        def init(self, name: Literal["to"]) -> NavUpdate.LatLng: ...
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[NavUpdate.SegmentReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> NavUpdate.SegmentReader: ...
        @staticmethod
        def new_message() -> NavUpdate.SegmentBuilder: ...
        def to_dict(self) -> dict: ...
    class SegmentReader(NavUpdate.Segment):
        fromm: NavUpdate.LatLngReader
        to: NavUpdate.LatLngReader
        parts: Sequence[NavUpdate.LatLngReader]
        def as_builder(self) -> NavUpdate.SegmentBuilder: ...
    class SegmentBuilder(NavUpdate.Segment):
        fromm: NavUpdate.LatLng | NavUpdate.LatLngBuilder | NavUpdate.LatLngReader
        to: NavUpdate.LatLng | NavUpdate.LatLngBuilder | NavUpdate.LatLngReader
        parts: Sequence[NavUpdate.LatLng | NavUpdate.LatLngBuilder | NavUpdate.LatLngReader]
        @staticmethod
        def from_dict(dictionary: dict) -> NavUpdate.SegmentBuilder: ...
        def copy(self) -> NavUpdate.SegmentBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> NavUpdate.SegmentReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    isNavigating: bool
    curSegment: int
    segments: Sequence[NavUpdate.Segment | NavUpdate.SegmentBuilder | NavUpdate.SegmentReader]
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[NavUpdateReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> NavUpdateReader: ...
    @staticmethod
    def new_message() -> NavUpdateBuilder: ...
    def to_dict(self) -> dict: ...
class NavUpdateReader(NavUpdate):
    segments: Sequence[NavUpdate.SegmentReader]
    def as_builder(self) -> NavUpdateBuilder: ...
class NavUpdateBuilder(NavUpdate):
    segments: Sequence[NavUpdate.Segment | NavUpdate.SegmentBuilder | NavUpdate.SegmentReader]
    @staticmethod
    def from_dict(dictionary: dict) -> NavUpdateBuilder: ...
    def copy(self) -> NavUpdateBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> NavUpdateReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class TrafficEvent:
    Type = Literal["stopSign", "lightRed", "lightYellow", "lightGreen", "stopLight"]
    Action = Literal["none", "yield", "stop", "resumeReady"]
    type: TrafficEvent.Type
    distance: float
    action: TrafficEvent.Action
    resuming: bool
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[TrafficEventReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> TrafficEventReader: ...
    @staticmethod
    def new_message() -> TrafficEventBuilder: ...
    def to_dict(self) -> dict: ...
class TrafficEventReader(TrafficEvent):
    def as_builder(self) -> TrafficEventBuilder: ...
class TrafficEventBuilder(TrafficEvent):
    @staticmethod
    def from_dict(dictionary: dict) -> TrafficEventBuilder: ...
    def copy(self) -> TrafficEventBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> TrafficEventReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class AndroidGnss:
    class Measurements:
        class Clock:
            timeNanos: int
            hardwareClockDiscontinuityCount: int
            hasTimeUncertaintyNanos: bool
            timeUncertaintyNanos: float
            hasLeapSecond: bool
            leapSecond: int
            hasFullBiasNanos: bool
            fullBiasNanos: int
            hasBiasNanos: bool
            biasNanos: float
            hasBiasUncertaintyNanos: bool
            biasUncertaintyNanos: float
            hasDriftNanosPerSecond: bool
            driftNanosPerSecond: float
            hasDriftUncertaintyNanosPerSecond: bool
            driftUncertaintyNanosPerSecond: float
            @staticmethod
            @contextmanager
            def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[AndroidGnss.Measurements.ClockReader]: ...
            @staticmethod
            def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> AndroidGnss.Measurements.ClockReader: ...
            @staticmethod
            def new_message() -> AndroidGnss.Measurements.ClockBuilder: ...
            def to_dict(self) -> dict: ...
        class ClockReader(AndroidGnss.Measurements.Clock):
            def as_builder(self) -> AndroidGnss.Measurements.ClockBuilder: ...
        class ClockBuilder(AndroidGnss.Measurements.Clock):
            @staticmethod
            def from_dict(dictionary: dict) -> AndroidGnss.Measurements.ClockBuilder: ...
            def copy(self) -> AndroidGnss.Measurements.ClockBuilder: ...
            def to_bytes(self) -> bytes: ...
            def to_bytes_packed(self) -> bytes: ...
            def to_segments(self) -> list[bytes]: ...
            def as_reader(self) -> AndroidGnss.Measurements.ClockReader: ...
            @staticmethod
            def write(file: BufferedWriter) -> None: ...
            @staticmethod
            def write_packed(file: BufferedWriter) -> None: ...
        class Measurement:
            Constellation = Literal["unknown", "gps", "sbas", "glonass", "qzss", "beidou", "galileo"]
            MultipathIndicator = Literal["unknown", "detected", "notDetected"]
            svId: int
            constellation: AndroidGnss.Measurements.Measurement.Constellation
            timeOffsetNanos: float
            state: int
            receivedSvTimeNanos: int
            receivedSvTimeUncertaintyNanos: int
            cn0DbHz: float
            pseudorangeRateMetersPerSecond: float
            pseudorangeRateUncertaintyMetersPerSecond: float
            accumulatedDeltaRangeState: int
            accumulatedDeltaRangeMeters: float
            accumulatedDeltaRangeUncertaintyMeters: float
            hasCarrierFrequencyHz: bool
            carrierFrequencyHz: float
            hasCarrierCycles: bool
            carrierCycles: int
            hasCarrierPhase: bool
            carrierPhase: float
            hasCarrierPhaseUncertainty: bool
            carrierPhaseUncertainty: float
            hasSnrInDb: bool
            snrInDb: float
            multipathIndicator: AndroidGnss.Measurements.Measurement.MultipathIndicator
            @staticmethod
            @contextmanager
            def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[AndroidGnss.Measurements.MeasurementReader]: ...
            @staticmethod
            def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> AndroidGnss.Measurements.MeasurementReader: ...
            @staticmethod
            def new_message() -> AndroidGnss.Measurements.MeasurementBuilder: ...
            def to_dict(self) -> dict: ...
        class MeasurementReader(AndroidGnss.Measurements.Measurement):
            def as_builder(self) -> AndroidGnss.Measurements.MeasurementBuilder: ...
        class MeasurementBuilder(AndroidGnss.Measurements.Measurement):
            @staticmethod
            def from_dict(dictionary: dict) -> AndroidGnss.Measurements.MeasurementBuilder: ...
            def copy(self) -> AndroidGnss.Measurements.MeasurementBuilder: ...
            def to_bytes(self) -> bytes: ...
            def to_bytes_packed(self) -> bytes: ...
            def to_segments(self) -> list[bytes]: ...
            def as_reader(self) -> AndroidGnss.Measurements.MeasurementReader: ...
            @staticmethod
            def write(file: BufferedWriter) -> None: ...
            @staticmethod
            def write_packed(file: BufferedWriter) -> None: ...
        clock: AndroidGnss.Measurements.Clock | AndroidGnss.Measurements.ClockBuilder | AndroidGnss.Measurements.ClockReader
        measurements: Sequence[AndroidGnss.Measurements.Measurement | AndroidGnss.Measurements.MeasurementBuilder | AndroidGnss.Measurements.MeasurementReader]
        def init(self, name: Literal["clock"]) -> AndroidGnss.Measurements.Clock: ...
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[AndroidGnss.MeasurementsReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> AndroidGnss.MeasurementsReader: ...
        @staticmethod
        def new_message() -> AndroidGnss.MeasurementsBuilder: ...
        def to_dict(self) -> dict: ...
    class MeasurementsReader(AndroidGnss.Measurements):
        clock: AndroidGnss.Measurements.ClockReader
        measurements: Sequence[AndroidGnss.Measurements.MeasurementReader]
        def as_builder(self) -> AndroidGnss.MeasurementsBuilder: ...
    class MeasurementsBuilder(AndroidGnss.Measurements):
        clock: AndroidGnss.Measurements.Clock | AndroidGnss.Measurements.ClockBuilder | AndroidGnss.Measurements.ClockReader
        measurements: Sequence[AndroidGnss.Measurements.Measurement | AndroidGnss.Measurements.MeasurementBuilder | AndroidGnss.Measurements.MeasurementReader]
        @staticmethod
        def from_dict(dictionary: dict) -> AndroidGnss.MeasurementsBuilder: ...
        def copy(self) -> AndroidGnss.MeasurementsBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> AndroidGnss.MeasurementsReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    class NavigationMessage:
        Status = Literal["unknown", "parityPassed", "parityRebuilt"]
        type: int
        svId: int
        messageId: int
        submessageId: int
        data: bytes
        status: AndroidGnss.NavigationMessage.Status
        @staticmethod
        @contextmanager
        def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[AndroidGnss.NavigationMessageReader]: ...
        @staticmethod
        def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> AndroidGnss.NavigationMessageReader: ...
        @staticmethod
        def new_message() -> AndroidGnss.NavigationMessageBuilder: ...
        def to_dict(self) -> dict: ...
    class NavigationMessageReader(AndroidGnss.NavigationMessage):
        def as_builder(self) -> AndroidGnss.NavigationMessageBuilder: ...
    class NavigationMessageBuilder(AndroidGnss.NavigationMessage):
        @staticmethod
        def from_dict(dictionary: dict) -> AndroidGnss.NavigationMessageBuilder: ...
        def copy(self) -> AndroidGnss.NavigationMessageBuilder: ...
        def to_bytes(self) -> bytes: ...
        def to_bytes_packed(self) -> bytes: ...
        def to_segments(self) -> list[bytes]: ...
        def as_reader(self) -> AndroidGnss.NavigationMessageReader: ...
        @staticmethod
        def write(file: BufferedWriter) -> None: ...
        @staticmethod
        def write_packed(file: BufferedWriter) -> None: ...
    measurements: AndroidGnss.Measurements | AndroidGnss.MeasurementsBuilder | AndroidGnss.MeasurementsReader
    navigationMessage: AndroidGnss.NavigationMessage | AndroidGnss.NavigationMessageBuilder | AndroidGnss.NavigationMessageReader
    def which(self) -> Literal["measurements", "navigationMessage"]: ...
    @overload
    def init(self, name: Literal["measurements"]) -> AndroidGnss.Measurements: ...
    @overload
    def init(self, name: Literal["navigationMessage"]) -> AndroidGnss.NavigationMessage: ...
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[AndroidGnssReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> AndroidGnssReader: ...
    @staticmethod
    def new_message() -> AndroidGnssBuilder: ...
    def to_dict(self) -> dict: ...
class AndroidGnssReader(AndroidGnss):
    measurements: AndroidGnss.MeasurementsReader
    navigationMessage: AndroidGnss.NavigationMessageReader
    def as_builder(self) -> AndroidGnssBuilder: ...
class AndroidGnssBuilder(AndroidGnss):
    measurements: AndroidGnss.Measurements | AndroidGnss.MeasurementsBuilder | AndroidGnss.MeasurementsReader
    navigationMessage: AndroidGnss.NavigationMessage | AndroidGnss.NavigationMessageBuilder | AndroidGnss.NavigationMessageReader
    @staticmethod
    def from_dict(dictionary: dict) -> AndroidGnssBuilder: ...
    def copy(self) -> AndroidGnssBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> AndroidGnssReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
class LidarPts:
    r: Sequence[int]
    theta: Sequence[int]
    reflect: Sequence[int]
    idx: int
    pkt: bytes
    @staticmethod
    @contextmanager
    def from_bytes(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> Iterator[LidarPtsReader]: ...
    @staticmethod
    def from_bytes_packed(data: bytes, traversal_limit_in_words: int | None = ..., nesting_limit: int | None = ...) -> LidarPtsReader: ...
    @staticmethod
    def new_message() -> LidarPtsBuilder: ...
    def to_dict(self) -> dict: ...
class LidarPtsReader(LidarPts):
    def as_builder(self) -> LidarPtsBuilder: ...
class LidarPtsBuilder(LidarPts):
    @staticmethod
    def from_dict(dictionary: dict) -> LidarPtsBuilder: ...
    def copy(self) -> LidarPtsBuilder: ...
    def to_bytes(self) -> bytes: ...
    def to_bytes_packed(self) -> bytes: ...
    def to_segments(self) -> list[bytes]: ...
    def as_reader(self) -> LidarPtsReader: ...
    @staticmethod
    def write(file: BufferedWriter) -> None: ...
    @staticmethod
    def write_packed(file: BufferedWriter) -> None: ...
