# log.capnp
@0xf3b1f17e25a4285b;
$import "/include/c++.capnp".namespace("cereal");
$import "/include/java.capnp".package("ai.comma.openpilot.cereal");
$import "/include/java.capnp".outerClassname("Log");
const logVersion @0xd578fb3372ed5043 :Int32 = 1;
struct Map @0xf8b13ce2183eb696 (Key, Value) {  # 0 bytes, 1 ptrs
  entries @0 :List(Entry);  # ptr[0]
  struct Entry @0xa5dfdd084a6eea0e {  # 0 bytes, 2 ptrs
    key @0 :Key;  # ptr[0]
    value @1 :Value;  # ptr[1]
  }
}
struct InitData @0xe71008caeb3fb65c {  # 8 bytes, 15 ptrs
  kernelArgs @0 :List(Text);  # ptr[0]
  kernelVersion @15 :Text;  # ptr[12]
  gctx @1 :Text;  # ptr[1]
  dongleId @2 :Text;  # ptr[2]
  deviceType @3 :DeviceType;  # bits[0, 16)
  version @4 :Text;  # ptr[3]
  gitCommit @10 :Text;  # ptr[8]
  gitBranch @11 :Text;  # ptr[9]
  gitRemote @13 :Text;  # ptr[10]
  androidBuildInfo @5 :AndroidBuildInfo;  # ptr[4]
  androidSensors @6 :List(AndroidSensor);  # ptr[5]
  androidProperties @16 :Map(Text, Text);  # ptr[13]
  chffrAndroidExtra @7 :ChffrAndroidExtra;  # ptr[6]
  iosBuildInfo @14 :IosBuildInfo;  # ptr[11]
  pandaInfo @8 :PandaInfo;  # ptr[7]
  dirty @9 :Bool;  # bits[16, 17)
  passive @12 :Bool;  # bits[17, 18)
  params @17 :Map(Text, Text);  # ptr[14]
  enum DeviceType @0x9d5d7238eba86608 {
    unknown @0;
    neo @1;
    chffrAndroid @2;
    chffrIos @3;
    tici @4;
    pc @5;
  }
  struct AndroidBuildInfo @0xfe2919d5c21f426c {  # 16 bytes, 21 ptrs
    board @0 :Text;  # ptr[0]
    bootloader @1 :Text;  # ptr[1]
    brand @2 :Text;  # ptr[2]
    device @3 :Text;  # ptr[3]
    display @4 :Text;  # ptr[4]
    fingerprint @5 :Text;  # ptr[5]
    hardware @6 :Text;  # ptr[6]
    host @7 :Text;  # ptr[7]
    id @8 :Text;  # ptr[8]
    manufacturer @9 :Text;  # ptr[9]
    model @10 :Text;  # ptr[10]
    product @11 :Text;  # ptr[11]
    radioVersion @12 :Text;  # ptr[12]
    serial @13 :Text;  # ptr[13]
    supportedAbis @14 :List(Text);  # ptr[14]
    tags @15 :Text;  # ptr[15]
    time @16 :Int64;  # bits[0, 64)
    type @17 :Text;  # ptr[16]
    user @18 :Text;  # ptr[17]
    versionCodename @19 :Text;  # ptr[18]
    versionRelease @20 :Text;  # ptr[19]
    versionSdk @21 :Int32;  # bits[64, 96)
    versionSecurityPatch @22 :Text;  # ptr[20]
  }
  struct AndroidSensor @0x9b513b93a887dbcd {  # 48 bytes, 3 ptrs
    id @0 :Int32;  # bits[0, 32)
    name @1 :Text;  # ptr[0]
    vendor @2 :Text;  # ptr[1]
    version @3 :Int32;  # bits[32, 64)
    handle @4 :Int32;  # bits[64, 96)
    type @5 :Int32;  # bits[96, 128)
    maxRange @6 :Float32;  # bits[128, 160)
    resolution @7 :Float32;  # bits[160, 192)
    power @8 :Float32;  # bits[192, 224)
    minDelay @9 :Int32;  # bits[224, 256)
    fifoReservedEventCount @10 :UInt32;  # bits[256, 288)
    fifoMaxEventCount @11 :UInt32;  # bits[288, 320)
    stringType @12 :Text;  # ptr[2]
    maxDelay @13 :Int32;  # bits[320, 352)
  }
  struct ChffrAndroidExtra @0x9cfb5d53a4f615a5 {  # 0 bytes, 1 ptrs
    allCameraCharacteristics @0 :Map(Text, Text);  # ptr[0]
  }
  struct IosBuildInfo @0xd97e3b28239f5580 {  # 8 bytes, 3 ptrs
    appVersion @0 :Text;  # ptr[0]
    appBuild @1 :UInt32;  # bits[0, 32)
    osVersion @2 :Text;  # ptr[1]
    deviceModel @3 :Text;  # ptr[2]
  }
  struct PandaInfo @0xe673e8725cdff0ad {  # 8 bytes, 3 ptrs
    hasPanda @0 :Bool;  # bits[0, 1)
    dongleId @1 :Text;  # ptr[0]
    stVersion @2 :Text;  # ptr[1]
    espVersion @3 :Text;  # ptr[2]
  }
}
struct FrameData @0xea0245f695ae0a33 {  # 64 bytes, 6 ptrs
  frameId @0 :UInt32;  # bits[0, 32)
  encodeId @1 :UInt32;  # bits[32, 64)
  timestampEof @2 :UInt64;  # bits[64, 128)
  frameLength @3 :Int32;  # bits[128, 160)
  integLines @4 :Int32;  # bits[160, 192)
  globalGain @5 :Int32;  # bits[192, 224)
  lensPos @11 :Int32;  # bits[320, 352)
  lensSag @12 :Float32;  # bits[352, 384)
  lensErr @13 :Float32;  # bits[384, 416)
  lensTruePos @14 :Float32;  # bits[416, 448)
  image @6 :Data;  # ptr[0]
  gainFrac @15 :Float32;  # bits[448, 480)
  focusVal @16 :List(Int16);  # ptr[3]
  focusConf @17 :List(UInt8);  # ptr[4]
  sharpnessScore @18 :List(UInt16);  # ptr[5]
  recoverState @19 :Int32;  # bits[480, 512)
  frameType @7 :FrameType;  # bits[224, 240)
  timestampSof @8 :UInt64;  # bits[256, 320)
  transform @10 :List(Float32);  # ptr[2]
  androidCaptureResult @9 :AndroidCaptureResult;  # ptr[1]
  enum FrameType @0xddb169f01e102879 {
    unknown @0;
    neo @1;
    chffrAndroid @2;
    front @3;
  }
  struct AndroidCaptureResult @0xbcc3efbac41d2048 {  # 32 bytes, 2 ptrs
    sensitivity @0 :Int32;  # bits[0, 32)
    frameDuration @1 :Int64;  # bits[64, 128)
    exposureTime @2 :Int64;  # bits[128, 192)
    rollingShutterSkew @3 :UInt64;  # bits[192, 256)
    colorCorrectionTransform @4 :List(Int32);  # ptr[0]
    colorCorrectionGains @5 :List(Float32);  # ptr[1]
    displayRotation @6 :Int8;  # bits[32, 40)
  }
}
struct Thumbnail @0xb65fce64120af7d3 {  # 16 bytes, 1 ptrs
  frameId @0 :UInt32;  # bits[0, 32)
  timestampEof @1 :UInt64;  # bits[64, 128)
  thumbnail @2 :Data;  # ptr[0]
}
struct GPSNMEAData @0x9d291d7813ba4a88 {  # 16 bytes, 1 ptrs
  timestamp @0 :Int64;  # bits[0, 64)
  localWallTime @1 :UInt64;  # bits[64, 128)
  nmea @2 :Text;  # ptr[0]
}
struct SensorEventData @0xa2b29a69d44529a1 {  # 32 bytes, 1 ptrs
  version @0 :Int32;  # bits[0, 32)
  sensor @1 :Int32;  # bits[32, 64)
  type @2 :Int32;  # bits[64, 96)
  timestamp @3 :Int64;  # bits[128, 192)
  uncalibratedDEPRECATED @10 :Bool;  # bits[192, 193)
  union {  # tag bits [96, 112)
    acceleration @4 :SensorVec;  # ptr[0], union tag = 0
    magnetic @5 :SensorVec;  # ptr[0], union tag = 1
    orientation @6 :SensorVec;  # ptr[0], union tag = 2
    gyro @7 :SensorVec;  # ptr[0], union tag = 3
    pressure @9 :SensorVec;  # ptr[0], union tag = 4
    magneticUncalibrated @11 :SensorVec;  # ptr[0], union tag = 5
    gyroUncalibrated @12 :SensorVec;  # ptr[0], union tag = 6
    proximity @13 :Float32;  # bits[224, 256), union tag = 7
    light @14 :Float32;  # bits[224, 256), union tag = 8
    temperature @15 :Float32;  # bits[224, 256), union tag = 9
  }
  source @8 :SensorSource;  # bits[112, 128)
  struct SensorVec @0xa43429bd2bfc24fc {  # 8 bytes, 1 ptrs
    v @0 :List(Float32);  # ptr[0]
    status @1 :Int8;  # bits[0, 8)
  }
  enum SensorSource @0xe49b3ce8f7f48d0d {
    android @0;
    iOS @1;
    fiber @2;
    velodyne @3;
    bno055 @4;
    lsm6ds3 @5;
    bmp280 @6;
    mmc3416x @7;
    bmx055 @8;
    rpr0521 @9;
  }
}
struct GpsLocationData @0xe946524859add50e {  # 64 bytes, 1 ptrs
  flags @0 :UInt16;  # bits[0, 16)
  latitude @1 :Float64;  # bits[64, 128)
  longitude @2 :Float64;  # bits[128, 192)
  altitude @3 :Float64;  # bits[192, 256)
  speed @4 :Float32;  # bits[32, 64)
  bearing @5 :Float32;  # bits[256, 288)
  accuracy @6 :Float32;  # bits[288, 320)
  timestamp @7 :Int64;  # bits[320, 384)
  source @8 :SensorSource;  # bits[16, 32)
  vNED @9 :List(Float32);  # ptr[0]
  verticalAccuracy @10 :Float32;  # bits[384, 416)
  bearingAccuracy @11 :Float32;  # bits[416, 448)
  speedAccuracy @12 :Float32;  # bits[448, 480)
  enum SensorSource @0xd3ff79f25c734863 {
    android @0;
    iOS @1;
    car @2;
    velodyne @3;
    fusion @4;
    external @5;
    ublox @6;
    trimble @7;
  }
}
struct CanData @0x8785009a964c7c59 {  # 8 bytes, 1 ptrs
  address @0 :UInt32;  # bits[0, 32)
  busTime @1 :UInt16;  # bits[32, 48)
  dat @2 :Data;  # ptr[0]
  src @3 :UInt8;  # bits[48, 56)
}
struct ThermalData @0x8d8231a40b7fe6e0 {  # 72 bytes, 3 ptrs
  cpu0DEPRECATED @0 :UInt16;  # bits[0, 16)
  cpu1DEPRECATED @1 :UInt16;  # bits[16, 32)
  cpu2DEPRECATED @2 :UInt16;  # bits[32, 48)
  cpu3DEPRECATED @3 :UInt16;  # bits[48, 64)
  memDEPRECATED @4 :UInt16;  # bits[64, 80)
  gpuDEPRECATED @5 :UInt16;  # bits[80, 96)
  batDEPRECATED @6 :UInt32;  # bits[96, 128)
  pa0DEPRECATED @21 :UInt16;  # bits[368, 384)
  freeSpace @7 :Float32;  # bits[128, 160)
  batteryPercent @8 :Int16;  # bits[160, 176)
  batteryStatus @9 :Text;  # ptr[0]
  batteryCurrent @15 :Int32;  # bits[224, 256)
  batteryVoltage @16 :Int32;  # bits[320, 352)
  usbOnline @12 :Bool;  # bits[193, 194)
  networkType @22 :NetworkType;  # bits[384, 400)
  offroadPowerUsage @23 :UInt32;  # bits[416, 448)
  networkStrength @24 :NetworkStrength;  # bits[400, 416)
  carBatteryCapacity @25 :UInt32;  # bits[448, 480)
  fanSpeed @10 :UInt16;  # bits[176, 192)
  started @11 :Bool;  # bits[192, 193)
  startedTs @13 :UInt64;  # bits[256, 320)
  thermalStatus @14 :ThermalStatus;  # bits[208, 224)
  chargingError @17 :Bool;  # bits[194, 195)
  chargingDisabled @18 :Bool;  # bits[195, 196)
  memUsedPercent @19 :Int8;  # bits[200, 208)
  cpuPerc @20 :Int8;  # bits[352, 360)
  cpu @26 :List(Float32);  # ptr[1]
  gpu @27 :List(Float32);  # ptr[2]
  mem @28 :Float32;  # bits[480, 512)
  bat @29 :Float32;  # bits[512, 544)
  ambient @30 :Float32;  # bits[544, 576)
  enum ThermalStatus @0x98c15adf4549151f {
    green @0;
    yellow @1;
    red @2;
    danger @3;
  }
  enum NetworkType @0xbe9411d70903973e {
    none @0;
    wifi @1;
    cell2G @2;
    cell3G @3;
    cell4G @4;
    cell5G @5;
  }
  enum NetworkStrength @0xe3ad44fd1f180a02 {
    unknown @0;
    poor @1;
    moderate @2;
    good @3;
    great @4;
  }
}
struct HealthData @0xcfa2b0c2c82af1e4 {  # 40 bytes, 1 ptrs
  voltage @0 :UInt32;  # bits[0, 32)
  current @1 :UInt32;  # bits[32, 64)
  ignitionLine @2 :Bool;  # bits[64, 65)
  controlsAllowed @3 :Bool;  # bits[65, 66)
  gasInterceptorDetected @4 :Bool;  # bits[66, 67)
  startedSignalDetectedDeprecated @5 :Bool;  # bits[67, 68)
  hasGps @6 :Bool;  # bits[68, 69)
  canSendErrs @7 :UInt32;  # bits[96, 128)
  canFwdErrs @8 :UInt32;  # bits[128, 160)
  canRxErrs @19 :UInt32;  # bits[288, 320)
  gmlanSendErrs @9 :UInt32;  # bits[160, 192)
  hwType @10 :HwType;  # bits[80, 96)
  fanSpeedRpm @11 :UInt16;  # bits[192, 208)
  usbPowerMode @12 :UsbPowerMode;  # bits[208, 224)
  ignitionCan @13 :Bool;  # bits[69, 70)
  safetyModel @14 :import "/car.capnp".CarParams.SafetyModel;  # bits[224, 240)
  faultStatus @15 :FaultStatus;  # bits[240, 256)
  powerSaveEnabled @16 :Bool;  # bits[70, 71)
  uptime @17 :UInt32;  # bits[256, 288)
  faults @18 :List(FaultType);  # ptr[0]
  enum FaultStatus @0xdba986d5085e7841 {
    none @0;
    faultTemp @1;
    faultPerm @2;
  }
  enum FaultType @0x861b4c91fc3f20df {
    relayMalfunction @0;
    unusedInterruptHandled @1;
    interruptRateCan1 @2;
    interruptRateCan2 @3;
    interruptRateCan3 @4;
    interruptRateTach @5;
    interruptRateGmlan @6;
    interruptRateInterrupts @7;
    interruptRateSpiDma @8;
    interruptRateSpiCs @9;
    interruptRateUart1 @10;
    interruptRateUart2 @11;
    interruptRateUart3 @12;
    interruptRateUart5 @13;
    interruptRateUartDma @14;
    interruptRateUsb @15;
    interruptRateTim1 @16;
    interruptRateTim3 @17;
    registerDivergent @18;
    interruptRateKlineInit @19;
    interruptRateClockSource @20;
    interruptRateTim9 @21;
  }
  enum HwType @0x8a58adf93e5b3751 {
    unknown @0;
    whitePanda @1;
    greyPanda @2;
    blackPanda @3;
    pedal @4;
    uno @5;
    dos @6;
  }
  enum UsbPowerMode @0xc306478a6828188f {
    none @0;
    client @1;
    cdp @2;
    dcp @3;
  }
}
struct LiveUI @0xc08240f996aefced {  # 8 bytes, 2 ptrs
  rearViewCam @0 :Bool;  # bits[0, 1)
  alertText1 @1 :Text;  # ptr[0]
  alertText2 @2 :Text;  # ptr[1]
  awarenessStatus @3 :Float32;  # bits[32, 64)
}
struct RadarState @0x9a185389d6fdd05f {  # 40 bytes, 5 ptrs
  canMonoTimes @10 :List(UInt64);  # ptr[3]
  mdMonoTime @6 :UInt64;  # bits[128, 192)
  ftMonoTimeDEPRECATED @7 :UInt64;  # bits[192, 256)
  controlsStateMonoTime @11 :UInt64;  # bits[256, 320)
  radarErrors @12 :List(import "/car.capnp".RadarData.Error);  # ptr[4]
  warpMatrixDEPRECATED @0 :List(Float32);  # ptr[0]
  angleOffsetDEPRECATED @1 :Float32;  # bits[0, 32)
  calStatusDEPRECATED @2 :Int8;  # bits[32, 40)
  calCycleDEPRECATED @8 :Int32;  # bits[96, 128)
  calPercDEPRECATED @9 :Int8;  # bits[40, 48)
  leadOne @3 :LeadData;  # ptr[1]
  leadTwo @4 :LeadData;  # ptr[2]
  cumLagMs @5 :Float32;  # bits[64, 96)
  struct LeadData @0xb96f3ad9170cf085 {  # 56 bytes, 0 ptrs
    dRel @0 :Float32;  # bits[0, 32)
    yRel @1 :Float32;  # bits[32, 64)
    vRel @2 :Float32;  # bits[64, 96)
    aRel @3 :Float32;  # bits[96, 128)
    vLead @4 :Float32;  # bits[128, 160)
    aLeadDEPRECATED @5 :Float32;  # bits[160, 192)
    dPath @6 :Float32;  # bits[192, 224)
    vLat @7 :Float32;  # bits[224, 256)
    vLeadK @8 :Float32;  # bits[256, 288)
    aLeadK @9 :Float32;  # bits[288, 320)
    fcw @10 :Bool;  # bits[320, 321)
    status @11 :Bool;  # bits[321, 322)
    aLeadTau @12 :Float32;  # bits[352, 384)
    modelProb @13 :Float32;  # bits[384, 416)
    radar @14 :Bool;  # bits[322, 323)
  }
}
struct LiveCalibrationData @0x96df70754d8390bc {  # 16 bytes, 6 ptrs
  warpMatrix @0 :List(Float32);  # ptr[0]
  warpMatrix2 @5 :List(Float32);  # ptr[2]
  warpMatrixBig @6 :List(Float32);  # ptr[3]
  calStatus @1 :Int8;  # bits[0, 8)
  calCycle @2 :Int32;  # bits[32, 64)
  calPerc @3 :Int8;  # bits[8, 16)
  validBlocks @9 :Int32;  # bits[64, 96)
  extrinsicMatrix @4 :List(Float32);  # ptr[1]
  rpyCalib @7 :List(Float32);  # ptr[4]
  rpyCalibSpread @8 :List(Float32);  # ptr[5]
}
struct LiveTracks @0x8faa644732dec251 {  # 40 bytes, 0 ptrs
  trackId @0 :Int32;  # bits[0, 32)
  dRel @1 :Float32;  # bits[32, 64)
  yRel @2 :Float32;  # bits[64, 96)
  vRel @3 :Float32;  # bits[96, 128)
  aRel @4 :Float32;  # bits[128, 160)
  timeStamp @5 :Float32;  # bits[160, 192)
  status @6 :Float32;  # bits[192, 224)
  currentTime @7 :Float32;  # bits[224, 256)
  stationary @8 :Bool;  # bits[256, 257)
  oncoming @9 :Bool;  # bits[257, 258)
}
struct ControlsState @0x97ff69c53601abf1 {  # 176 bytes, 6 ptrs
  canMonoTimeDEPRECATED @16 :UInt64;  # bits[512, 576)
  canMonoTimes @21 :List(UInt64);  # ptr[0]
  radarStateMonoTimeDEPRECATED @17 :UInt64;  # bits[576, 640)
  mdMonoTimeDEPRECATED @18 :UInt64;  # bits[640, 704)
  planMonoTime @28 :UInt64;  # bits[832, 896)
  pathPlanMonoTime @50 :UInt64;  # bits[1280, 1344)
  state @31 :OpenpilotState;  # bits[928, 944)
  vEgo @0 :Float32;  # bits[0, 32)
  vEgoRaw @32 :Float32;  # bits[960, 992)
  aEgoDEPRECATED @1 :Float32;  # bits[32, 64)
  longControlState @30 :LongControlState;  # bits[720, 736)
  vPid @2 :Float32;  # bits[64, 96)
  vTargetLead @3 :Float32;  # bits[96, 128)
  upAccelCmd @4 :Float32;  # bits[128, 160)
  uiAccelCmd @5 :Float32;  # bits[160, 192)
  ufAccelCmd @33 :Float32;  # bits[992, 1024)
  yActualDEPRECATED @6 :Float32;  # bits[192, 224)
  yDesDEPRECATED @7 :Float32;  # bits[224, 256)
  upSteerDEPRECATED @8 :Float32;  # bits[256, 288)
  uiSteerDEPRECATED @9 :Float32;  # bits[288, 320)
  ufSteerDEPRECATED @34 :Float32;  # bits[1024, 1056)
  aTargetMinDEPRECATED @10 :Float32;  # bits[320, 352)
  aTargetMaxDEPRECATED @11 :Float32;  # bits[352, 384)
  aTarget @35 :Float32;  # bits[1056, 1088)
  jerkFactor @12 :Float32;  # bits[384, 416)
  angleSteers @13 :Float32;  # bits[416, 448)
  angleSteersDes @29 :Float32;  # bits[896, 928)
  curvature @37 :Float32;  # bits[1088, 1120)
  hudLeadDEPRECATED @14 :Int32;  # bits[448, 480)
  cumLagMs @15 :Float32;  # bits[480, 512)
  startMonoTime @48 :UInt64;  # bits[1216, 1280)
  mapValid @49 :Bool;  # bits[712, 713)
  forceDecel @51 :Bool;  # bits[713, 714)
  enabled @19 :Bool;  # bits[704, 705)
  active @36 :Bool;  # bits[707, 708)
  steerOverride @20 :Bool;  # bits[705, 706)
  vCruise @22 :Float32;  # bits[736, 768)
  rearViewCam @23 :Bool;  # bits[706, 707)
  alertText1 @24 :Text;  # ptr[1]
  alertText2 @25 :Text;  # ptr[2]
  alertStatus @38 :AlertStatus;  # bits[944, 960)
  alertSize @39 :AlertSize;  # bits[1120, 1136)
  alertBlinkingRate @42 :Float32;  # bits[1152, 1184)
  alertType @44 :Text;  # ptr[3]
  alertSoundDEPRECATED @45 :Text;  # ptr[4]
  alertSound @56 :import "/car.capnp".CarControl.HUDControl.AudibleAlert;  # bits[1344, 1360)
  awarenessStatus @26 :Float32;  # bits[768, 800)
  angleModelBiasDEPRECATED @27 :Float32;  # bits[800, 832)
  gpsPlannerActive @40 :Bool;  # bits[708, 709)
  engageable @41 :Bool;  # bits[709, 710)
  driverMonitoringOn @43 :Bool;  # bits[710, 711)
  vCurvature @46 :Float32;  # bits[1184, 1216)
  decelForTurn @47 :Bool;  # bits[711, 712)
  decelForModel @54 :Bool;  # bits[714, 715)
  canErrorCounter @57 :UInt32;  # bits[1376, 1408)
  lateralControlState :group {
    union {  # tag bits [1136, 1152)
      indiState @52 :LateralINDIState;  # ptr[5], union tag = 0
      pidState @53 :LateralPIDState;  # ptr[5], union tag = 1
      lqrState @55 :LateralLQRState;  # ptr[5], union tag = 2
    }
  }
  enum OpenpilotState @0xdbe58b96d2d1ac61 {
    disabled @0;
    preEnabled @1;
    enabled @2;
    softDisabling @3;
  }
  enum LongControlState @0xe40f3a917d908282 {
    off @0;
    pid @1;
    stopping @2;
    starting @3;
  }
  enum AlertStatus @0xa0d0dcd113193c62 {
    normal @0;
    userPrompt @1;
    critical @2;
  }
  enum AlertSize @0xe98bb99d6e985f64 {
    none @0;
    small @1;
    mid @2;
    full @3;
  }
  struct LateralINDIState @0x939463348632375e {  # 40 bytes, 0 ptrs
    active @0 :Bool;  # bits[0, 1)
    steerAngle @1 :Float32;  # bits[32, 64)
    steerRate @2 :Float32;  # bits[64, 96)
    steerAccel @3 :Float32;  # bits[96, 128)
    rateSetPoint @4 :Float32;  # bits[128, 160)
    accelSetPoint @5 :Float32;  # bits[160, 192)
    accelError @6 :Float32;  # bits[192, 224)
    delayedOutput @7 :Float32;  # bits[224, 256)
    delta @8 :Float32;  # bits[256, 288)
    output @9 :Float32;  # bits[288, 320)
    saturated @10 :Bool;  # bits[1, 2)
  }
  struct LateralPIDState @0xf28c5dc9e09375e3 {  # 32 bytes, 0 ptrs
    active @0 :Bool;  # bits[0, 1)
    steerAngle @1 :Float32;  # bits[32, 64)
    steerRate @2 :Float32;  # bits[64, 96)
    angleError @3 :Float32;  # bits[96, 128)
    p @4 :Float32;  # bits[128, 160)
    i @5 :Float32;  # bits[160, 192)
    f @6 :Float32;  # bits[192, 224)
    output @7 :Float32;  # bits[224, 256)
    saturated @8 :Bool;  # bits[1, 2)
  }
  struct LateralLQRState @0x9024e2d790c82ade {  # 24 bytes, 0 ptrs
    active @0 :Bool;  # bits[0, 1)
    steerAngle @1 :Float32;  # bits[32, 64)
    i @2 :Float32;  # bits[64, 96)
    output @3 :Float32;  # bits[96, 128)
    lqrOutput @4 :Float32;  # bits[128, 160)
    saturated @5 :Bool;  # bits[1, 2)
  }
}
struct LiveEventData @0x94b7baa90c5c321e {  # 8 bytes, 1 ptrs
  name @0 :Text;  # ptr[0]
  value @1 :Int32;  # bits[0, 32)
}
struct ModelData @0xb8aad62cffef28a9 {  # 32 bytes, 11 ptrs
  frameId @0 :UInt32;  # bits[0, 32)
  frameAge @12 :UInt32;  # bits[32, 64)
  frameDropPerc @13 :Float32;  # bits[128, 160)
  timestampEof @9 :UInt64;  # bits[64, 128)
  modelExecutionTime @14 :Float32;  # bits[160, 192)
  gpuExecutionTime @16 :Float32;  # bits[192, 224)
  rawPred @15 :Data;  # ptr[10]
  path @1 :PathData;  # ptr[0]
  leftLane @2 :PathData;  # ptr[1]
  rightLane @3 :PathData;  # ptr[2]
  lead @4 :LeadData;  # ptr[3]
  freePath @6 :List(Float32);  # ptr[5]
  settings @5 :ModelSettings;  # ptr[4]
  leadFuture @7 :LeadData;  # ptr[6]
  speed @8 :List(Float32);  # ptr[7]
  meta @10 :MetaData;  # ptr[8]
  longitudinal @11 :LongitudinalData;  # ptr[9]
  struct PathData @0x8817eeea389e9f08 {  # 16 bytes, 3 ptrs
    points @0 :List(Float32);  # ptr[0]
    prob @1 :Float32;  # bits[0, 32)
    std @2 :Float32;  # bits[32, 64)
    stds @3 :List(Float32);  # ptr[1]
    poly @4 :List(Float32);  # ptr[2]
    validLen @5 :Float32;  # bits[64, 96)
  }
  struct LeadData @0xd1c9bef96d26fa91 {  # 40 bytes, 0 ptrs
    dist @0 :Float32;  # bits[0, 32)
    prob @1 :Float32;  # bits[32, 64)
    std @2 :Float32;  # bits[64, 96)
    relVel @3 :Float32;  # bits[96, 128)
    relVelStd @4 :Float32;  # bits[128, 160)
    relY @5 :Float32;  # bits[160, 192)
    relYStd @6 :Float32;  # bits[192, 224)
    relA @7 :Float32;  # bits[224, 256)
    relAStd @8 :Float32;  # bits[256, 288)
  }
  struct ModelSettings @0xa26e3710efd3e914 {  # 8 bytes, 3 ptrs
    bigBoxX @0 :UInt16;  # bits[0, 16)
    bigBoxY @1 :UInt16;  # bits[16, 32)
    bigBoxWidth @2 :UInt16;  # bits[32, 48)
    bigBoxHeight @3 :UInt16;  # bits[48, 64)
    boxProjection @4 :List(Float32);  # ptr[0]
    yuvCorrection @5 :List(Float32);  # ptr[1]
    inputTransform @6 :List(Float32);  # ptr[2]
  }
  struct MetaData @0x9744f25fb60f2bf8 {  # 16 bytes, 2 ptrs
    engagedProb @0 :Float32;  # bits[0, 32)
    desirePrediction @1 :List(Float32);  # ptr[0]
    brakeDisengageProb @2 :Float32;  # bits[32, 64)
    gasDisengageProb @3 :Float32;  # bits[64, 96)
    steerOverrideProb @4 :Float32;  # bits[96, 128)
    desireState @5 :List(Float32);  # ptr[1]
  }
  struct LongitudinalData @0xf98f999c6a071122 {  # 0 bytes, 3 ptrs
    distances @2 :List(Float32);  # ptr[2]
    speeds @0 :List(Float32);  # ptr[0]
    accelerations @1 :List(Float32);  # ptr[1]
  }
}
struct ModelDataV2 @0xc4713f6b0d36abe9 {  # 32 bytes, 12 ptrs
  frameId @0 :UInt32;  # bits[0, 32)
  frameAge @1 :UInt32;  # bits[32, 64)
  frameDropPerc @2 :Float32;  # bits[64, 96)
  timestampEof @3 :UInt64;  # bits[128, 192)
  modelExecutionTime @15 :Float32;  # bits[96, 128)
  gpuExecutionTime @17 :Float32;  # bits[192, 224)
  rawPred @16 :Data;  # ptr[11]
  position @4 :XYZTData;  # ptr[0]
  orientation @5 :XYZTData;  # ptr[1]
  velocity @6 :XYZTData;  # ptr[2]
  orientationRate @7 :XYZTData;  # ptr[3]
  laneLines @8 :List(XYZTData);  # ptr[4]
  laneLineProbs @9 :List(Float32);  # ptr[5]
  laneLineStds @13 :List(Float32);  # ptr[9]
  roadEdges @10 :List(XYZTData);  # ptr[6]
  roadEdgeStds @14 :List(Float32);  # ptr[10]
  leads @11 :List(LeadDataV2);  # ptr[7]
  meta @12 :MetaData;  # ptr[8]
  struct XYZTData @0xc3cbae1fd505ae80 {  # 0 bytes, 7 ptrs
    x @0 :List(Float32);  # ptr[0]
    y @1 :List(Float32);  # ptr[1]
    z @2 :List(Float32);  # ptr[2]
    t @3 :List(Float32);  # ptr[3]
    xStd @4 :List(Float32);  # ptr[4]
    yStd @5 :List(Float32);  # ptr[5]
    zStd @6 :List(Float32);  # ptr[6]
  }
  struct LeadDataV2 @0xa444ed2b2187af28 {  # 8 bytes, 2 ptrs
    prob @0 :Float32;  # bits[0, 32)
    t @1 :Float32;  # bits[32, 64)
    xyva @2 :List(Float32);  # ptr[0]
    xyvaStd @3 :List(Float32);  # ptr[1]
  }
  struct MetaData @0xd1646ab3b45cfabd {  # 16 bytes, 2 ptrs
    engagedProb @0 :Float32;  # bits[0, 32)
    desirePrediction @1 :List(Float32);  # ptr[0]
    brakeDisengageProb @2 :Float32;  # bits[32, 64)
    gasDisengageProb @3 :Float32;  # bits[64, 96)
    steerOverrideProb @4 :Float32;  # bits[96, 128)
    desireState @5 :List(Float32);  # ptr[1]
  }
}
struct CalibrationFeatures @0x8fdfadb254ea867a {  # 8 bytes, 3 ptrs
  frameId @0 :UInt32;  # bits[0, 32)
  p0 @1 :List(Float32);  # ptr[0]
  p1 @2 :List(Float32);  # ptr[1]
  status @3 :List(Int8);  # ptr[2]
}
struct EncodeIndex @0x89d394e3541735fc {  # 40 bytes, 0 ptrs
  frameId @0 :UInt32;  # bits[0, 32)
  type @1 :Type;  # bits[32, 48)
  encodeId @2 :UInt32;  # bits[64, 96)
  segmentNum @3 :Int32;  # bits[96, 128)
  segmentId @4 :UInt32;  # bits[128, 160)
  segmentIdEncode @5 :UInt32;  # bits[160, 192)
  timestampSof @6 :UInt64;  # bits[192, 256)
  timestampEof @7 :UInt64;  # bits[256, 320)
  enum Type @0xc0ad259ec157ccd3 {
    bigBoxLossless @0;
    fullHEVC @1;
    bigBoxHEVC @2;
    chffrAndroidH264 @3;
    fullLosslessClip @4;
    front @5;
  }
}
struct AndroidLogEntry @0xea095da1894f7d85 {  # 24 bytes, 2 ptrs
  id @0 :UInt8;  # bits[0, 8)
  ts @1 :UInt64;  # bits[64, 128)
  priority @2 :UInt8;  # bits[8, 16)
  pid @3 :Int32;  # bits[32, 64)
  tid @4 :Int32;  # bits[128, 160)
  tag @5 :Text;  # ptr[0]
  message @6 :Text;  # ptr[1]
}
struct LogRotate @0x9811e1f38f62f2d1 {  # 8 bytes, 1 ptrs
  segmentNum @0 :Int32;  # bits[0, 32)
  path @1 :Text;  # ptr[0]
}
struct Plan @0xe00b5b3eba12876c {  # 80 bytes, 3 ptrs
  mdMonoTime @9 :UInt64;  # bits[192, 256)
  radarStateMonoTime @10 :UInt64;  # bits[256, 320)
  commIssue @31 :Bool;  # bits[11, 12)
  eventsDEPRECATED @13 :List(import "/car.capnp".CarEvent);  # ptr[2]
  lateralValidDEPRECATED @0 :Bool;  # bits[0, 1)
  dPolyDEPRECATED @1 :List(Float32);  # ptr[0]
  laneWidthDEPRECATED @11 :Float32;  # bits[160, 192)
  longitudinalValidDEPRECATED @2 :Bool;  # bits[1, 2)
  vCruise @16 :Float32;  # bits[352, 384)
  aCruise @17 :Float32;  # bits[384, 416)
  vTarget @3 :Float32;  # bits[32, 64)
  vTargetFuture @14 :Float32;  # bits[320, 352)
  vMax @20 :Float32;  # bits[448, 480)
  aTargetMinDEPRECATED @4 :Float32;  # bits[64, 96)
  aTargetMaxDEPRECATED @5 :Float32;  # bits[96, 128)
  aTarget @18 :Float32;  # bits[416, 448)
  vStart @26 :Float32;  # bits[512, 544)
  aStart @27 :Float32;  # bits[544, 576)
  jerkFactor @6 :Float32;  # bits[128, 160)
  hasLead @7 :Bool;  # bits[2, 3)
  hasLeftLaneDEPRECATED @23 :Bool;  # bits[6, 7)
  hasRightLaneDEPRECATED @24 :Bool;  # bits[7, 8)
  fcw @8 :Bool;  # bits[3, 4)
  longitudinalPlanSource @15 :LongitudinalPlanSource;  # bits[16, 32)
  gpsTrajectory @12 :GpsTrajectory;  # ptr[1]
  gpsPlannerActive @19 :Bool;  # bits[4, 5)
  vCurvature @21 :Float32;  # bits[480, 512)
  decelForTurn @22 :Bool;  # bits[5, 6)
  mapValid @25 :Bool;  # bits[8, 9)
  radarValid @28 :Bool;  # bits[9, 10)
  radarCanError @30 :Bool;  # bits[10, 11)
  processingDelay @29 :Float32;  # bits[576, 608)
  struct GpsTrajectory @0x8cfeb072f5301000 {  # 0 bytes, 2 ptrs
    x @0 :List(Float32);  # ptr[0]
    y @1 :List(Float32);  # ptr[1]
  }
  enum LongitudinalPlanSource @0xb231a753cc079120 {
    cruise @0;
    mpc1 @1;
    mpc2 @2;
    mpc3 @3;
    model @4;
  }
}
struct PathPlan @0xe1e9318e2ae8b51e {  # 40 bytes, 5 ptrs
  laneWidth @0 :Float32;  # bits[0, 32)
  lProb @5 :Float32;  # bits[64, 96)
  rProb @7 :Float32;  # bits[96, 128)
  dPathPoints @20 :List(Float32);  # ptr[4]
  dProb @21 :Float32;  # bits[288, 320)
  cProbDEPRECATED @3 :Float32;  # bits[32, 64)
  dPolyDEPRECATED @1 :List(Float32);  # ptr[0]
  cPolyDEPRECATED @2 :List(Float32);  # ptr[1]
  lPolyDEPRECATED @4 :List(Float32);  # ptr[2]
  rPolyDEPRECATED @6 :List(Float32);  # ptr[3]
  angleSteers @8 :Float32;  # bits[128, 160)
  rateSteers @13 :Float32;  # bits[224, 256)
  mpcSolutionValid @9 :Bool;  # bits[160, 161)
  paramsValid @10 :Bool;  # bits[161, 162)
  modelValidDEPRECATED @12 :Bool;  # bits[162, 163)
  angleOffset @11 :Float32;  # bits[192, 224)
  sensorValid @14 :Bool;  # bits[163, 164)
  commIssue @15 :Bool;  # bits[164, 165)
  posenetValid @16 :Bool;  # bits[165, 166)
  desire @17 :Desire;  # bits[176, 192)
  laneChangeState @18 :LaneChangeState;  # bits[256, 272)
  laneChangeDirection @19 :LaneChangeDirection;  # bits[272, 288)
  enum Desire @0xbb53ef3fcf2a7f0d {
    none @0;
    turnLeft @1;
    turnRight @2;
    laneChangeLeft @3;
    laneChangeRight @4;
    keepLeft @5;
    keepRight @6;
  }
  enum LaneChangeState @0xfac297f195ce56d2 {
    off @0;
    preLaneChange @1;
    laneChangeStarting @2;
    laneChangeFinishing @3;
  }
  enum LaneChangeDirection @0xf7396311bcbad303 {
    none @0;
    left @1;
    right @2;
  }
}
struct LiveLocationKalman @0xebc5703d1ee7c129 {  # 24 bytes, 14 ptrs
  positionECEF @0 :Measurement;  # ptr[0]
  positionGeodetic @1 :Measurement;  # ptr[1]
  velocityECEF @2 :Measurement;  # ptr[2]
  velocityNED @3 :Measurement;  # ptr[3]
  velocityDevice @4 :Measurement;  # ptr[4]
  accelerationDevice @5 :Measurement;  # ptr[5]
  orientationECEF @6 :Measurement;  # ptr[6]
  calibratedOrientationECEF @20 :Measurement;  # ptr[13]
  orientationNED @7 :Measurement;  # ptr[7]
  angularVelocityDevice @8 :Measurement;  # ptr[8]
  orientationNEDCalibrated @9 :Measurement;  # ptr[9]
  velocityCalibrated @10 :Measurement;  # ptr[10]
  accelerationCalibrated @11 :Measurement;  # ptr[11]
  angularVelocityCalibrated @12 :Measurement;  # ptr[12]
  gpsWeek @13 :Int32;  # bits[0, 32)
  gpsTimeOfWeek @14 :Float64;  # bits[64, 128)
  status @15 :Status;  # bits[32, 48)
  unixTimestampMillis @16 :Int64;  # bits[128, 192)
  inputsOK @17 :Bool = true;  # bits[48, 49)
  posenetOK @18 :Bool = true;  # bits[49, 50)
  gpsOK @19 :Bool = true;  # bits[50, 51)
  sensorsOK @21 :Bool = true;  # bits[51, 52)
  deviceStable @22 :Bool = true;  # bits[52, 53)
  enum Status @0x8e4dc8cc4b51fc01 {
    uninitialized @0;
    uncalibrated @1;
    valid @2;
  }
  struct Measurement @0xbf23f9ed66dace1c {  # 8 bytes, 2 ptrs
    value @0 :List(Float64);  # ptr[0]
    std @1 :List(Float64);  # ptr[1]
    valid @2 :Bool;  # bits[0, 1)
  }
}
struct LiveLocationData @0xb99b2bc7a57e8128 {  # 80 bytes, 7 ptrs
  status @0 :UInt8;  # bits[0, 8)
  lat @1 :Float64;  # bits[64, 128)
  lon @2 :Float64;  # bits[128, 192)
  alt @3 :Float32;  # bits[32, 64)
  speed @4 :Float32;  # bits[192, 224)
  vNED @5 :List(Float32);  # ptr[0]
  roll @6 :Float32;  # bits[224, 256)
  pitch @7 :Float32;  # bits[256, 288)
  heading @8 :Float32;  # bits[288, 320)
  wanderAngle @9 :Float32;  # bits[320, 352)
  trackAngle @10 :Float32;  # bits[352, 384)
  gyro @11 :List(Float32);  # ptr[1]
  accel @12 :List(Float32);  # ptr[2]
  accuracy @13 :Accuracy;  # ptr[3]
  source @14 :SensorSource;  # bits[16, 32)
  fixMonoTime @15 :UInt64;  # bits[384, 448)
  gpsWeek @16 :Int32;  # bits[448, 480)
  timeOfWeek @17 :Float64;  # bits[512, 576)
  positionECEF @18 :List(Float64);  # ptr[4]
  poseQuatECEF @19 :List(Float32);  # ptr[5]
  pitchCalibration @20 :Float32;  # bits[480, 512)
  yawCalibration @21 :Float32;  # bits[576, 608)
  imuFrame @22 :List(Float32);  # ptr[6]
  struct Accuracy @0x943dc4625473b03f {  # 24 bytes, 2 ptrs
    pNEDError @0 :List(Float32);  # ptr[0]
    vNEDError @1 :List(Float32);  # ptr[1]
    rollError @2 :Float32;  # bits[0, 32)
    pitchError @3 :Float32;  # bits[32, 64)
    headingError @4 :Float32;  # bits[64, 96)
    ellipsoidSemiMajorError @5 :Float32;  # bits[96, 128)
    ellipsoidSemiMinorError @6 :Float32;  # bits[128, 160)
    ellipsoidOrientationError @7 :Float32;  # bits[160, 192)
  }
  enum SensorSource @0xc871d3cc252af657 {
    applanix @0;
    kalman @1;
    orbslam @2;
    timing @3;
    dummy @4;
  }
}
struct EthernetPacket @0xa99a9d5b33cf5859 {  # 8 bytes, 1 ptrs
  pkt @0 :Data;  # ptr[0]
  ts @1 :Float32;  # bits[0, 32)
}
struct NavUpdate @0xdb98be6565516acb {  # 8 bytes, 1 ptrs
  isNavigating @0 :Bool;  # bits[0, 1)
  curSegment @1 :Int32;  # bits[32, 64)
  segments @2 :List(Segment);  # ptr[0]
  struct LatLng @0x9eaef9187cadbb9b {  # 16 bytes, 0 ptrs
    lat @0 :Float64;  # bits[0, 64)
    lng @1 :Float64;  # bits[64, 128)
  }
  struct Segment @0xa5b39b4fc4d7da3f {  # 24 bytes, 3 ptrs
    from @0 :LatLng;  # ptr[0]
    to @1 :LatLng;  # ptr[1]
    updateTime @2 :Int32;  # bits[0, 32)
    distance @3 :Int32;  # bits[32, 64)
    crossTime @4 :Int32;  # bits[64, 96)
    exitNo @5 :Int32;  # bits[96, 128)
    instruction @6 :Instruction;  # bits[128, 144)
    parts @7 :List(LatLng);  # ptr[2]
    enum Instruction @0xc5417a637451246f {
      turnLeft @0;
      turnRight @1;
      keepLeft @2;
      keepRight @3;
      straight @4;
      roundaboutExitNumber @5;
      roundaboutExit @6;
      roundaboutTurnLeft @7;
      unkn8 @8;
      roundaboutStraight @9;
      unkn10 @10;
      roundaboutTurnRight @11;
      unkn12 @12;
      roundaboutUturn @13;
      unkn14 @14;
      arrive @15;
      exitLeft @16;
      exitRight @17;
      unkn18 @18;
      uturn @19;
    }
  }
}
struct NavStatus @0xbd8822120928120c {  # 8 bytes, 1 ptrs
  isNavigating @0 :Bool;  # bits[0, 1)
  currentAddress @1 :Address;  # ptr[0]
  struct Address @0xce7cd672cacc7814 {  # 16 bytes, 7 ptrs
    title @0 :Text;  # ptr[0]
    lat @1 :Float64;  # bits[0, 64)
    lng @2 :Float64;  # bits[64, 128)
    house @3 :Text;  # ptr[1]
    address @4 :Text;  # ptr[2]
    street @5 :Text;  # ptr[3]
    city @6 :Text;  # ptr[4]
    state @7 :Text;  # ptr[5]
    country @8 :Text;  # ptr[6]
  }
}
struct CellInfo @0xcff7566681c277ce {  # 8 bytes, 1 ptrs
  timestamp @0 :UInt64;  # bits[0, 64)
  repr @1 :Text;  # ptr[0]
}
struct WifiScan @0xd4df5a192382ba0b {  # 40 bytes, 5 ptrs
  bssid @0 :Text;  # ptr[0]
  ssid @1 :Text;  # ptr[1]
  capabilities @2 :Text;  # ptr[2]
  frequency @3 :Int32;  # bits[0, 32)
  level @4 :Int32;  # bits[32, 64)
  timestamp @5 :Int64;  # bits[64, 128)
  centerFreq0 @6 :Int32;  # bits[128, 160)
  centerFreq1 @7 :Int32;  # bits[160, 192)
  channelWidth @8 :ChannelWidth;  # bits[192, 208)
  operatorFriendlyName @9 :Text;  # ptr[3]
  venueName @10 :Text;  # ptr[4]
  is80211mcResponder @11 :Bool;  # bits[208, 209)
  passpoint @12 :Bool;  # bits[209, 210)
  distanceCm @13 :Int32;  # bits[224, 256)
  distanceSdCm @14 :Int32;  # bits[256, 288)
  enum ChannelWidth @0xcb6a279f015f6b51 {
    w20Mhz @0;
    w40Mhz @1;
    w80Mhz @2;
    w160Mhz @3;
    w80Plus80Mhz @4;
  }
}
struct AndroidGnss @0xdfdf30d03fc485bd {  # 8 bytes, 1 ptrs
  union {  # tag bits [0, 16)
    measurements @0 :Measurements;  # ptr[0], union tag = 0
    navigationMessage @1 :NavigationMessage;  # ptr[0], union tag = 1
  }
  struct Measurements @0xa20710d4f428d6cd {  # 0 bytes, 2 ptrs
    clock @0 :Clock;  # ptr[0]
    measurements @1 :List(Measurement);  # ptr[1]
    struct Clock @0xa0e27b453a38f450 {  # 72 bytes, 0 ptrs
      timeNanos @0 :Int64;  # bits[0, 64)
      hardwareClockDiscontinuityCount @1 :Int32;  # bits[64, 96)
      hasTimeUncertaintyNanos @2 :Bool;  # bits[96, 97)
      timeUncertaintyNanos @3 :Float64;  # bits[128, 192)
      hasLeapSecond @4 :Bool;  # bits[97, 98)
      leapSecond @5 :Int32;  # bits[192, 224)
      hasFullBiasNanos @6 :Bool;  # bits[98, 99)
      fullBiasNanos @7 :Int64;  # bits[256, 320)
      hasBiasNanos @8 :Bool;  # bits[99, 100)
      biasNanos @9 :Float64;  # bits[320, 384)
      hasBiasUncertaintyNanos @10 :Bool;  # bits[100, 101)
      biasUncertaintyNanos @11 :Float64;  # bits[384, 448)
      hasDriftNanosPerSecond @12 :Bool;  # bits[101, 102)
      driftNanosPerSecond @13 :Float64;  # bits[448, 512)
      hasDriftUncertaintyNanosPerSecond @14 :Bool;  # bits[102, 103)
      driftUncertaintyNanosPerSecond @15 :Float64;  # bits[512, 576)
    }
    struct Measurement @0xd949bf717d77614d {  # 120 bytes, 0 ptrs
      svId @0 :Int32;  # bits[0, 32)
      constellation @1 :Constellation;  # bits[32, 48)
      timeOffsetNanos @2 :Float64;  # bits[64, 128)
      state @3 :Int32;  # bits[128, 160)
      receivedSvTimeNanos @4 :Int64;  # bits[192, 256)
      receivedSvTimeUncertaintyNanos @5 :Int64;  # bits[256, 320)
      cn0DbHz @6 :Float64;  # bits[320, 384)
      pseudorangeRateMetersPerSecond @7 :Float64;  # bits[384, 448)
      pseudorangeRateUncertaintyMetersPerSecond @8 :Float64;  # bits[448, 512)
      accumulatedDeltaRangeState @9 :Int32;  # bits[160, 192)
      accumulatedDeltaRangeMeters @10 :Float64;  # bits[512, 576)
      accumulatedDeltaRangeUncertaintyMeters @11 :Float64;  # bits[576, 640)
      hasCarrierFrequencyHz @12 :Bool;  # bits[48, 49)
      carrierFrequencyHz @13 :Float32;  # bits[640, 672)
      hasCarrierCycles @14 :Bool;  # bits[49, 50)
      carrierCycles @15 :Int64;  # bits[704, 768)
      hasCarrierPhase @16 :Bool;  # bits[50, 51)
      carrierPhase @17 :Float64;  # bits[768, 832)
      hasCarrierPhaseUncertainty @18 :Bool;  # bits[51, 52)
      carrierPhaseUncertainty @19 :Float64;  # bits[832, 896)
      hasSnrInDb @20 :Bool;  # bits[52, 53)
      snrInDb @21 :Float64;  # bits[896, 960)
      multipathIndicator @22 :MultipathIndicator;  # bits[672, 688)
      enum Constellation @0x9ef1f3ff0deb5ffb {
        unknown @0;
        gps @1;
        sbas @2;
        glonass @3;
        qzss @4;
        beidou @5;
        galileo @6;
      }
      enum State @0xcbb9490adce12d72 {
        unknown @0;
        codeLock @1;
        bitSync @2;
        subframeSync @3;
        towDecoded @4;
        msecAmbiguous @5;
        symbolSync @6;
        gloStringSync @7;
        gloTodDecoded @8;
        bdsD2BitSync @9;
        bdsD2SubframeSync @10;
        galE1bcCodeLock @11;
        galE1c2ndCodeLock @12;
        galE1bPageSync @13;
        sbasSync @14;
      }
      enum MultipathIndicator @0xc04e7b6231d4caa8 {
        unknown @0;
        detected @1;
        notDetected @2;
      }
    }
  }
  struct NavigationMessage @0xe2517b083095fd4e {  # 24 bytes, 1 ptrs
    type @0 :Int32;  # bits[0, 32)
    svId @1 :Int32;  # bits[32, 64)
    messageId @2 :Int32;  # bits[64, 96)
    submessageId @3 :Int32;  # bits[96, 128)
    data @4 :Data;  # ptr[0]
    status @5 :Status;  # bits[128, 144)
    enum Status @0xec1ff7996b35366f {
      unknown @0;
      parityPassed @1;
      parityRebuilt @2;
    }
  }
}
struct QcomGnss @0xde94674b07ae51c1 {  # 16 bytes, 1 ptrs
  logTs @0 :UInt64;  # bits[0, 64)
  union {  # tag bits [64, 80)
    measurementReport @1 :MeasurementReport;  # ptr[0], union tag = 0
    clockReport @2 :ClockReport;  # ptr[0], union tag = 1
    drMeasurementReport @3 :DrMeasurementReport;  # ptr[0], union tag = 2
    drSvPoly @4 :DrSvPolyReport;  # ptr[0], union tag = 3
    rawLog @5 :Data;  # ptr[0], union tag = 4
  }
  enum MeasurementSource @0xd71a12b6faada7ee {
    gps @0;
    glonass @1;
    beidou @2;
  }
  enum SVObservationState @0xe81e829a0d6c83e9 {
    idle @0;
    search @1;
    searchVerify @2;
    bitEdge @3;
    trackVerify @4;
    track @5;
    restart @6;
    dpo @7;
    glo10msBe @8;
    glo10msAt @9;
  }
  struct MeasurementStatus @0xe501010e1bcae83b {  # 8 bytes, 0 ptrs
    subMillisecondIsValid @0 :Bool;  # bits[0, 1)
    subBitTimeIsKnown @1 :Bool;  # bits[1, 2)
    satelliteTimeIsKnown @2 :Bool;  # bits[2, 3)
    bitEdgeConfirmedFromSignal @3 :Bool;  # bits[3, 4)
    measuredVelocity @4 :Bool;  # bits[4, 5)
    fineOrCoarseVelocity @5 :Bool;  # bits[5, 6)
    lockPointValid @6 :Bool;  # bits[6, 7)
    lockPointPositive @7 :Bool;  # bits[7, 8)
    lastUpdateFromDifference @8 :Bool;  # bits[8, 9)
    lastUpdateFromVelocityDifference @9 :Bool;  # bits[9, 10)
    strongIndicationOfCrossCorelation @10 :Bool;  # bits[10, 11)
    tentativeMeasurement @11 :Bool;  # bits[11, 12)
    measurementNotUsable @12 :Bool;  # bits[12, 13)
    sirCheckIsNeeded @13 :Bool;  # bits[13, 14)
    probationMode @14 :Bool;  # bits[14, 15)
    glonassMeanderBitEdgeValid @15 :Bool;  # bits[15, 16)
    glonassTimeMarkValid @16 :Bool;  # bits[16, 17)
    gpsRoundRobinRxDiversity @17 :Bool;  # bits[17, 18)
    gpsRxDiversity @18 :Bool;  # bits[18, 19)
    gpsLowBandwidthRxDiversityCombined @19 :Bool;  # bits[19, 20)
    gpsHighBandwidthNu4 @20 :Bool;  # bits[20, 21)
    gpsHighBandwidthNu8 @21 :Bool;  # bits[21, 22)
    gpsHighBandwidthUniform @22 :Bool;  # bits[22, 23)
    multipathIndicator @23 :Bool;  # bits[23, 24)
    imdJammingIndicator @24 :Bool;  # bits[24, 25)
    lteB13TxJammingIndicator @25 :Bool;  # bits[25, 26)
    freshMeasurementIndicator @26 :Bool;  # bits[26, 27)
    multipathEstimateIsValid @27 :Bool;  # bits[27, 28)
    directionIsValid @28 :Bool;  # bits[28, 29)
  }
  struct MeasurementReport @0xf580d7d86b7b8692 {  # 32 bytes, 1 ptrs
    source @0 :MeasurementSource;  # bits[0, 16)
    fCount @1 :UInt32;  # bits[32, 64)
    gpsWeek @2 :UInt16;  # bits[16, 32)
    glonassCycleNumber @3 :UInt8;  # bits[64, 72)
    glonassNumberOfDays @4 :UInt16;  # bits[80, 96)
    milliseconds @5 :UInt32;  # bits[96, 128)
    timeBias @6 :Float32;  # bits[128, 160)
    clockTimeUncertainty @7 :Float32;  # bits[160, 192)
    clockFrequencyBias @8 :Float32;  # bits[192, 224)
    clockFrequencyUncertainty @9 :Float32;  # bits[224, 256)
    sv @10 :List(SV);  # ptr[0]
    struct SV @0xf10c595ae7bb2c27 {  # 64 bytes, 1 ptrs
      svId @0 :UInt8;  # bits[0, 8)
      observationState @2 :SVObservationState;  # bits[16, 32)
      observations @3 :UInt8;  # bits[32, 40)
      goodObservations @4 :UInt8;  # bits[40, 48)
      gpsParityErrorCount @5 :UInt16;  # bits[48, 64)
      glonassFrequencyIndex @1 :Int8;  # bits[8, 16)
      glonassHemmingErrorCount @6 :UInt8;  # bits[64, 72)
      filterStages @7 :UInt8;  # bits[72, 80)
      carrierNoise @8 :UInt16;  # bits[80, 96)
      latency @9 :Int16;  # bits[96, 112)
      predetectInterval @10 :UInt8;  # bits[112, 120)
      postdetections @11 :UInt16;  # bits[128, 144)
      unfilteredMeasurementIntegral @12 :UInt32;  # bits[160, 192)
      unfilteredMeasurementFraction @13 :Float32;  # bits[192, 224)
      unfilteredTimeUncertainty @14 :Float32;  # bits[224, 256)
      unfilteredSpeed @15 :Float32;  # bits[256, 288)
      unfilteredSpeedUncertainty @16 :Float32;  # bits[288, 320)
      measurementStatus @17 :MeasurementStatus;  # ptr[0]
      multipathEstimate @18 :UInt32;  # bits[320, 352)
      azimuth @19 :Float32;  # bits[352, 384)
      elevation @20 :Float32;  # bits[384, 416)
      carrierPhaseCyclesIntegral @21 :Int32;  # bits[416, 448)
      carrierPhaseCyclesFraction @22 :UInt16;  # bits[144, 160)
      fineSpeed @23 :Float32;  # bits[448, 480)
      fineSpeedUncertainty @24 :Float32;  # bits[480, 512)
      cycleSlipCount @25 :UInt8;  # bits[120, 128)
    }
  }
  struct ClockReport @0xca965e4add8f4f0b {  # 144 bytes, 0 ptrs
    hasFCount @0 :Bool;  # bits[0, 1)
    fCount @1 :UInt32;  # bits[32, 64)
    hasGpsWeek @2 :Bool;  # bits[1, 2)
    gpsWeek @3 :UInt16;  # bits[16, 32)
    hasGpsMilliseconds @4 :Bool;  # bits[2, 3)
    gpsMilliseconds @5 :UInt32;  # bits[64, 96)
    gpsTimeBias @6 :Float32;  # bits[96, 128)
    gpsClockTimeUncertainty @7 :Float32;  # bits[128, 160)
    gpsClockSource @8 :UInt8;  # bits[8, 16)
    hasGlonassYear @9 :Bool;  # bits[3, 4)
    glonassYear @10 :UInt8;  # bits[160, 168)
    hasGlonassDay @11 :Bool;  # bits[4, 5)
    glonassDay @12 :UInt16;  # bits[176, 192)
    hasGlonassMilliseconds @13 :Bool;  # bits[5, 6)
    glonassMilliseconds @14 :UInt32;  # bits[192, 224)
    glonassTimeBias @15 :Float32;  # bits[224, 256)
    glonassClockTimeUncertainty @16 :Float32;  # bits[256, 288)
    glonassClockSource @17 :UInt8;  # bits[168, 176)
    bdsWeek @18 :UInt16;  # bits[288, 304)
    bdsMilliseconds @19 :UInt32;  # bits[320, 352)
    bdsTimeBias @20 :Float32;  # bits[352, 384)
    bdsClockTimeUncertainty @21 :Float32;  # bits[384, 416)
    bdsClockSource @22 :UInt8;  # bits[304, 312)
    galWeek @23 :UInt16;  # bits[416, 432)
    galMilliseconds @24 :UInt32;  # bits[448, 480)
    galTimeBias @25 :Float32;  # bits[480, 512)
    galClockTimeUncertainty @26 :Float32;  # bits[512, 544)
    galClockSource @27 :UInt8;  # bits[312, 320)
    clockFrequencyBias @28 :Float32;  # bits[544, 576)
    clockFrequencyUncertainty @29 :Float32;  # bits[576, 608)
    frequencySource @30 :UInt8;  # bits[432, 440)
    gpsLeapSeconds @31 :UInt8;  # bits[440, 448)
    gpsLeapSecondsUncertainty @32 :UInt8;  # bits[608, 616)
    gpsLeapSecondsSource @33 :UInt8;  # bits[616, 624)
    gpsToGlonassTimeBiasMilliseconds @34 :Float32;  # bits[640, 672)
    gpsToGlonassTimeBiasMillisecondsUncertainty @35 :Float32;  # bits[672, 704)
    gpsToBdsTimeBiasMilliseconds @36 :Float32;  # bits[704, 736)
    gpsToBdsTimeBiasMillisecondsUncertainty @37 :Float32;  # bits[736, 768)
    bdsToGloTimeBiasMilliseconds @38 :Float32;  # bits[768, 800)
    bdsToGloTimeBiasMillisecondsUncertainty @39 :Float32;  # bits[800, 832)
    gpsToGalTimeBiasMilliseconds @40 :Float32;  # bits[832, 864)
    gpsToGalTimeBiasMillisecondsUncertainty @41 :Float32;  # bits[864, 896)
    galToGloTimeBiasMilliseconds @42 :Float32;  # bits[896, 928)
    galToGloTimeBiasMillisecondsUncertainty @43 :Float32;  # bits[928, 960)
    galToBdsTimeBiasMilliseconds @44 :Float32;  # bits[960, 992)
    galToBdsTimeBiasMillisecondsUncertainty @45 :Float32;  # bits[992, 1024)
    hasRtcTime @46 :Bool;  # bits[6, 7)
    systemRtcTime @47 :UInt32;  # bits[1024, 1056)
    fCountOffset @48 :UInt32;  # bits[1056, 1088)
    lpmRtcCount @49 :UInt32;  # bits[1088, 1120)
    clockResets @50 :UInt32;  # bits[1120, 1152)
  }
  struct DrMeasurementReport @0x8053c39445c6c75c {  # 80 bytes, 1 ptrs
    reason @0 :UInt8;  # bits[0, 8)
    seqNum @1 :UInt8;  # bits[8, 16)
    seqMax @2 :UInt8;  # bits[16, 24)
    rfLoss @3 :UInt16;  # bits[32, 48)
    systemRtcValid @4 :Bool;  # bits[24, 25)
    fCount @5 :UInt32;  # bits[64, 96)
    clockResets @6 :UInt32;  # bits[96, 128)
    systemRtcTime @7 :UInt64;  # bits[128, 192)
    gpsLeapSeconds @8 :UInt8;  # bits[48, 56)
    gpsLeapSecondsUncertainty @9 :UInt8;  # bits[56, 64)
    gpsToGlonassTimeBiasMilliseconds @10 :Float32;  # bits[192, 224)
    gpsToGlonassTimeBiasMillisecondsUncertainty @11 :Float32;  # bits[224, 256)
    gpsWeek @12 :UInt16;  # bits[256, 272)
    gpsMilliseconds @13 :UInt32;  # bits[288, 320)
    gpsTimeBiasMs @14 :UInt32;  # bits[320, 352)
    gpsClockTimeUncertaintyMs @15 :UInt32;  # bits[352, 384)
    gpsClockSource @16 :UInt8;  # bits[272, 280)
    glonassClockSource @17 :UInt8;  # bits[280, 288)
    glonassYear @18 :UInt8;  # bits[384, 392)
    glonassDay @19 :UInt16;  # bits[400, 416)
    glonassMilliseconds @20 :UInt32;  # bits[416, 448)
    glonassTimeBias @21 :Float32;  # bits[448, 480)
    glonassClockTimeUncertainty @22 :Float32;  # bits[480, 512)
    clockFrequencyBias @23 :Float32;  # bits[512, 544)
    clockFrequencyUncertainty @24 :Float32;  # bits[544, 576)
    frequencySource @25 :UInt8;  # bits[392, 400)
    source @26 :MeasurementSource;  # bits[576, 592)
    sv @27 :List(SV);  # ptr[0]
    struct SV @0xf08b81df8cbf459c {  # 96 bytes, 1 ptrs
      svId @0 :UInt8;  # bits[0, 8)
      glonassFrequencyIndex @1 :Int8;  # bits[8, 16)
      observationState @2 :SVObservationState;  # bits[16, 32)
      observations @3 :UInt8;  # bits[32, 40)
      goodObservations @4 :UInt8;  # bits[40, 48)
      filterStages @5 :UInt8;  # bits[48, 56)
      predetectInterval @6 :UInt8;  # bits[56, 64)
      cycleSlipCount @7 :UInt8;  # bits[64, 72)
      postdetections @8 :UInt16;  # bits[80, 96)
      measurementStatus @9 :MeasurementStatus;  # ptr[0]
      carrierNoise @10 :UInt16;  # bits[96, 112)
      rfLoss @11 :UInt16;  # bits[112, 128)
      latency @12 :Int16;  # bits[128, 144)
      filteredMeasurementFraction @13 :Float32;  # bits[160, 192)
      filteredMeasurementIntegral @14 :UInt32;  # bits[192, 224)
      filteredTimeUncertainty @15 :Float32;  # bits[224, 256)
      filteredSpeed @16 :Float32;  # bits[256, 288)
      filteredSpeedUncertainty @17 :Float32;  # bits[288, 320)
      unfilteredMeasurementFraction @18 :Float32;  # bits[320, 352)
      unfilteredMeasurementIntegral @19 :UInt32;  # bits[352, 384)
      unfilteredTimeUncertainty @20 :Float32;  # bits[384, 416)
      unfilteredSpeed @21 :Float32;  # bits[416, 448)
      unfilteredSpeedUncertainty @22 :Float32;  # bits[448, 480)
      multipathEstimate @23 :UInt32;  # bits[480, 512)
      azimuth @24 :Float32;  # bits[512, 544)
      elevation @25 :Float32;  # bits[544, 576)
      dopplerAcceleration @26 :Float32;  # bits[576, 608)
      fineSpeed @27 :Float32;  # bits[608, 640)
      fineSpeedUncertainty @28 :Float32;  # bits[640, 672)
      carrierPhase @29 :Float64;  # bits[704, 768)
      fCount @30 :UInt32;  # bits[672, 704)
      parityErrorCount @31 :UInt16;  # bits[144, 160)
      goodParity @32 :Bool;  # bits[72, 73)
    }
  }
  struct DrSvPolyReport @0xb1fb80811a673270 {  # 56 bytes, 4 ptrs
    svId @0 :UInt16;  # bits[0, 16)
    frequencyIndex @1 :Int8;  # bits[16, 24)
    hasPosition @2 :Bool;  # bits[24, 25)
    hasIono @3 :Bool;  # bits[25, 26)
    hasTropo @4 :Bool;  # bits[26, 27)
    hasElevation @5 :Bool;  # bits[27, 28)
    polyFromXtra @6 :Bool;  # bits[28, 29)
    hasSbasIono @7 :Bool;  # bits[29, 30)
    iode @8 :UInt16;  # bits[32, 48)
    t0 @9 :Float64;  # bits[64, 128)
    xyz0 @10 :List(Float64);  # ptr[0]
    xyzN @11 :List(Float64);  # ptr[1]
    other @12 :List(Float32);  # ptr[2]
    positionUncertainty @13 :Float32;  # bits[128, 160)
    ionoDelay @14 :Float32;  # bits[160, 192)
    ionoDot @15 :Float32;  # bits[192, 224)
    sbasIonoDelay @16 :Float32;  # bits[224, 256)
    sbasIonoDot @17 :Float32;  # bits[256, 288)
    tropoDelay @18 :Float32;  # bits[288, 320)
    elevation @19 :Float32;  # bits[320, 352)
    elevationDot @20 :Float32;  # bits[352, 384)
    elevationUncertainty @21 :Float32;  # bits[384, 416)
    velocityCoeff @22 :List(Float64);  # ptr[3]
  }
}
struct LidarPts @0xe3d6685d4e9d8f7a {  # 8 bytes, 4 ptrs
  r @0 :List(UInt16);  # ptr[0]
  theta @1 :List(UInt16);  # ptr[1]
  reflect @2 :List(UInt8);  # ptr[2]
  idx @3 :UInt64;  # bits[0, 64)
  pkt @4 :Data;  # ptr[3]
}
struct ProcLog @0xaf85387b3f681406 {  # 0 bytes, 3 ptrs
  cpuTimes @0 :List(CPUTimes);  # ptr[0]
  mem @1 :Mem;  # ptr[1]
  procs @2 :List(Process);  # ptr[2]
  struct Process @0xb0b85613f19e6d28 {  # 72 bytes, 3 ptrs
    pid @0 :Int32;  # bits[0, 32)
    name @1 :Text;  # ptr[0]
    state @2 :UInt8;  # bits[32, 40)
    ppid @3 :Int32;  # bits[64, 96)
    cpuUser @4 :Float32;  # bits[96, 128)
    cpuSystem @5 :Float32;  # bits[128, 160)
    cpuChildrenUser @6 :Float32;  # bits[160, 192)
    cpuChildrenSystem @7 :Float32;  # bits[192, 224)
    priority @8 :Int64;  # bits[256, 320)
    nice @9 :Int32;  # bits[224, 256)
    numThreads @10 :Int32;  # bits[320, 352)
    startTime @11 :Float64;  # bits[384, 448)
    memVms @12 :UInt64;  # bits[448, 512)
    memRss @13 :UInt64;  # bits[512, 576)
    processor @14 :Int32;  # bits[352, 384)
    cmdline @15 :List(Text);  # ptr[1]
    exe @16 :Text;  # ptr[2]
  }
  struct CPUTimes @0xf189c8c5bf2ce087 {  # 40 bytes, 0 ptrs
    cpuNum @0 :Int64;  # bits[0, 64)
    user @1 :Float32;  # bits[64, 96)
    nice @2 :Float32;  # bits[96, 128)
    system @3 :Float32;  # bits[128, 160)
    idle @4 :Float32;  # bits[160, 192)
    iowait @5 :Float32;  # bits[192, 224)
    irq @6 :Float32;  # bits[224, 256)
    softirq @7 :Float32;  # bits[256, 288)
  }
  struct Mem @0xfd095f94f08b3fd4 {  # 64 bytes, 0 ptrs
    total @0 :UInt64;  # bits[0, 64)
    free @1 :UInt64;  # bits[64, 128)
    available @2 :UInt64;  # bits[128, 192)
    buffers @3 :UInt64;  # bits[192, 256)
    cached @4 :UInt64;  # bits[256, 320)
    active @5 :UInt64;  # bits[320, 384)
    inactive @6 :UInt64;  # bits[384, 448)
    shared @7 :UInt64;  # bits[448, 512)
  }
}
struct UbloxGnss @0x85dddd7ce6cefa5d {  # 8 bytes, 1 ptrs
  union {  # tag bits [0, 16)
    measurementReport @0 :MeasurementReport;  # ptr[0], union tag = 0
    ephemeris @1 :Ephemeris;  # ptr[0], union tag = 1
    ionoData @2 :IonoData;  # ptr[0], union tag = 2
    hwStatus @3 :HwStatus;  # ptr[0], union tag = 3
  }
  struct MeasurementReport @0xa73ba546a29820f4 {  # 16 bytes, 2 ptrs
    rcvTow @0 :Float64;  # bits[0, 64)
    gpsWeek @1 :UInt16;  # bits[64, 80)
    leapSeconds @2 :UInt16;  # bits[80, 96)
    receiverStatus @3 :ReceiverStatus;  # ptr[0]
    numMeas @4 :UInt8;  # bits[96, 104)
    measurements @5 :List(Measurement);  # ptr[1]
    struct ReceiverStatus @0xfbb838d65160aab6 {  # 8 bytes, 0 ptrs
      leapSecValid @0 :Bool;  # bits[0, 1)
      clkReset @1 :Bool;  # bits[1, 2)
    }
    struct Measurement @0x8f8a655f5e326401 {  # 40 bytes, 1 ptrs
      svId @0 :UInt8;  # bits[0, 8)
      trackingStatus @1 :TrackingStatus;  # ptr[0]
      pseudorange @2 :Float64;  # bits[64, 128)
      carrierCycles @3 :Float64;  # bits[128, 192)
      doppler @4 :Float32;  # bits[32, 64)
      gnssId @5 :UInt8;  # bits[8, 16)
      glonassFrequencyIndex @6 :UInt8;  # bits[16, 24)
      locktime @7 :UInt16;  # bits[192, 208)
      cno @8 :UInt8;  # bits[24, 32)
      pseudorangeStdev @9 :Float32;  # bits[224, 256)
      carrierPhaseStdev @10 :Float32;  # bits[256, 288)
      dopplerStdev @11 :Float32;  # bits[288, 320)
      sigId @12 :UInt8;  # bits[208, 216)
      struct TrackingStatus @0xe8efb3a802b299b2 {  # 8 bytes, 0 ptrs
        pseudorangeValid @0 :Bool;  # bits[0, 1)
        carrierPhaseValid @1 :Bool;  # bits[1, 2)
        halfCycleValid @2 :Bool;  # bits[2, 3)
        halfCycleSubtracted @3 :Bool;  # bits[3, 4)
      }
    }
  }
  struct Ephemeris @0xd8418c788118f85c {  # 264 bytes, 2 ptrs
    svId @0 :UInt16;  # bits[0, 16)
    year @1 :UInt16;  # bits[16, 32)
    month @2 :UInt16;  # bits[32, 48)
    day @3 :UInt16;  # bits[48, 64)
    hour @4 :UInt16;  # bits[64, 80)
    minute @5 :UInt16;  # bits[80, 96)
    second @6 :Float32;  # bits[96, 128)
    af0 @7 :Float64;  # bits[128, 192)
    af1 @8 :Float64;  # bits[192, 256)
    af2 @9 :Float64;  # bits[256, 320)
    iode @10 :Float64;  # bits[320, 384)
    crs @11 :Float64;  # bits[384, 448)
    deltaN @12 :Float64;  # bits[448, 512)
    m0 @13 :Float64;  # bits[512, 576)
    cuc @14 :Float64;  # bits[576, 640)
    ecc @15 :Float64;  # bits[640, 704)
    cus @16 :Float64;  # bits[704, 768)
    a @17 :Float64;  # bits[768, 832)
    toe @18 :Float64;  # bits[832, 896)
    cic @19 :Float64;  # bits[896, 960)
    omega0 @20 :Float64;  # bits[960, 1024)
    cis @21 :Float64;  # bits[1024, 1088)
    i0 @22 :Float64;  # bits[1088, 1152)
    crc @23 :Float64;  # bits[1152, 1216)
    omega @24 :Float64;  # bits[1216, 1280)
    omegaDot @25 :Float64;  # bits[1280, 1344)
    iDot @26 :Float64;  # bits[1344, 1408)
    codesL2 @27 :Float64;  # bits[1408, 1472)
    gpsWeek @28 :Float64;  # bits[1472, 1536)
    l2 @29 :Float64;  # bits[1536, 1600)
    svAcc @30 :Float64;  # bits[1600, 1664)
    svHealth @31 :Float64;  # bits[1664, 1728)
    tgd @32 :Float64;  # bits[1728, 1792)
    iodc @33 :Float64;  # bits[1792, 1856)
    transmissionTime @34 :Float64;  # bits[1856, 1920)
    fitInterval @35 :Float64;  # bits[1920, 1984)
    toc @36 :Float64;  # bits[1984, 2048)
    ionoCoeffsValid @37 :Bool;  # bits[2048, 2049)
    ionoAlpha @38 :List(Float64);  # ptr[0]
    ionoBeta @39 :List(Float64);  # ptr[1]
  }
  struct IonoData @0xc3a3a8de519a4a26 {  # 24 bytes, 2 ptrs
    svHealth @0 :UInt32;  # bits[0, 32)
    tow @1 :Float64;  # bits[64, 128)
    gpsWeek @2 :Float64;  # bits[128, 192)
    ionoAlpha @3 :List(Float64);  # ptr[0]
    ionoBeta @4 :List(Float64);  # ptr[1]
    healthValid @5 :Bool;  # bits[32, 33)
    ionoCoeffsValid @6 :Bool;  # bits[33, 34)
  }
  struct HwStatus @0xebb036b114275aa8 {  # 16 bytes, 0 ptrs
    noisePerMS @0 :UInt16;  # bits[0, 16)
    agcCnt @1 :UInt16;  # bits[16, 32)
    aStatus @2 :AntennaSupervisorState;  # bits[32, 48)
    aPower @3 :AntennaPowerStatus;  # bits[48, 64)
    jamInd @4 :UInt8;  # bits[64, 72)
    enum AntennaSupervisorState @0xc23e1128ab4d5b53 {
      init @0;
      dontknow @1;
      ok @2;
      short @3;
      open @4;
    }
    enum AntennaPowerStatus @0xfe3b51a924e46559 {
      off @0;
      on @1;
      dontknow @2;
    }
  }
}
struct Clocks @0xc95fb49a7bdc4618 {  # 40 bytes, 0 ptrs
  bootTimeNanos @0 :UInt64;  # bits[0, 64)
  monotonicNanos @1 :UInt64;  # bits[64, 128)
  monotonicRawNanos @2 :UInt64;  # bits[128, 192)
  wallTimeNanos @3 :UInt64;  # bits[192, 256)
  modemUptimeMillis @4 :UInt64;  # bits[256, 320)
}
struct LiveMpcData @0x92a5e332a85f32a0 {  # 24 bytes, 4 ptrs
  x @0 :List(Float32);  # ptr[0]
  y @1 :List(Float32);  # ptr[1]
  psi @2 :List(Float32);  # ptr[2]
  delta @3 :List(Float32);  # ptr[3]
  qpIterations @4 :UInt32;  # bits[0, 32)
  calculationTime @5 :UInt64;  # bits[64, 128)
  cost @6 :Float64;  # bits[128, 192)
}
struct LiveLongitudinalMpcData @0xe7e17c434f865ae2 {  # 32 bytes, 6 ptrs
  xEgo @0 :List(Float32);  # ptr[0]
  vEgo @1 :List(Float32);  # ptr[1]
  aEgo @2 :List(Float32);  # ptr[2]
  xLead @3 :List(Float32);  # ptr[3]
  vLead @4 :List(Float32);  # ptr[4]
  aLead @5 :List(Float32);  # ptr[5]
  aLeadTau @6 :Float32;  # bits[0, 32)
  qpIterations @7 :UInt32;  # bits[32, 64)
  mpcId @8 :UInt32;  # bits[64, 96)
  calculationTime @9 :UInt64;  # bits[128, 192)
  cost @10 :Float64;  # bits[192, 256)
}
struct ECEFPointDEPRECATED @0xe10e21168db0c7f7 {  # 16 bytes, 0 ptrs
  x @0 :Float32;  # bits[0, 32)
  y @1 :Float32;  # bits[32, 64)
  z @2 :Float32;  # bits[64, 96)
}
struct ECEFPoint @0xc25bbbd524983447 {  # 24 bytes, 0 ptrs
  x @0 :Float64;  # bits[0, 64)
  y @1 :Float64;  # bits[64, 128)
  z @2 :Float64;  # bits[128, 192)
}
struct GPSPlannerPoints @0xab54c59699f8f9f3 {  # 16 bytes, 5 ptrs
  curPosDEPRECATED @0 :ECEFPointDEPRECATED;  # ptr[0]
  pointsDEPRECATED @1 :List(ECEFPointDEPRECATED);  # ptr[1]
  curPos @6 :ECEFPoint;  # ptr[3]
  points @7 :List(ECEFPoint);  # ptr[4]
  valid @2 :Bool;  # bits[0, 1)
  trackName @3 :Text;  # ptr[2]
  speedLimit @4 :Float32;  # bits[32, 64)
  accelTarget @5 :Float32;  # bits[64, 96)
}
struct GPSPlannerPlan @0xf5ad1d90cdc1dd6b {  # 16 bytes, 4 ptrs
  valid @0 :Bool;  # bits[0, 1)
  poly @1 :List(Float32);  # ptr[0]
  trackName @2 :Text;  # ptr[1]
  speed @3 :Float32;  # bits[32, 64)
  acceleration @4 :Float32;  # bits[64, 96)
  pointsDEPRECATED @5 :List(ECEFPointDEPRECATED);  # ptr[2]
  points @6 :List(ECEFPoint);  # ptr[3]
  xLookahead @7 :Float32;  # bits[96, 128)
}
struct TrafficEvent @0xacfa74a094e62626 {  # 16 bytes, 0 ptrs
  type @0 :Type;  # bits[0, 16)
  distance @1 :Float32;  # bits[32, 64)
  action @2 :Action;  # bits[16, 32)
  resuming @3 :Bool;  # bits[64, 65)
  enum Type @0xd85d75253435bf4b {
    stopSign @0;
    lightRed @1;
    lightYellow @2;
    lightGreen @3;
    stopLight @4;
  }
  enum Action @0xa6f6ce72165ccb49 {
    none @0;
    yield @1;
    stop @2;
    resumeReady @3;
  }
}
struct OrbslamCorrection @0x8afd33dc9b35e1aa {  # 16 bytes, 4 ptrs
  correctionMonoTime @0 :UInt64;  # bits[0, 64)
  prePositionECEF @1 :List(Float64);  # ptr[0]
  postPositionECEF @2 :List(Float64);  # ptr[1]
  prePoseQuatECEF @3 :List(Float32);  # ptr[2]
  postPoseQuatECEF @4 :List(Float32);  # ptr[3]
  numInliers @5 :UInt32;  # bits[64, 96)
}
struct OrbObservation @0x9b326d4e436afec7 {  # 16 bytes, 2 ptrs
  observationMonoTime @0 :UInt64;  # bits[0, 64)
  normalizedCoordinates @1 :List(Float32);  # ptr[0]
  locationECEF @2 :List(Float64);  # ptr[1]
  matchDistance @3 :UInt32;  # bits[64, 96)
}
struct UiNavigationEvent @0x90c8426c3eaddd3b {  # 8 bytes, 2 ptrs
  type @0 :Type;  # bits[0, 16)
  status @1 :Status;  # bits[16, 32)
  distanceTo @2 :Float32;  # bits[32, 64)
  endRoadPointDEPRECATED @3 :ECEFPointDEPRECATED;  # ptr[0]
  endRoadPoint @4 :ECEFPoint;  # ptr[1]
  enum Type @0xe8db07dcf8fcea05 {
    none @0;
    laneChangeLeft @1;
    laneChangeRight @2;
    mergeLeft @3;
    mergeRight @4;
    turnLeft @5;
    turnRight @6;
  }
  enum Status @0xb9aa88c75ef99a1f {
    none @0;
    passive @1;
    approaching @2;
    active @3;
  }
}
struct UiLayoutState @0x88dcce08ad29dda0 {  # 8 bytes, 0 ptrs
  activeApp @0 :App;  # bits[0, 16)
  sidebarCollapsed @1 :Bool;  # bits[16, 17)
  mapEnabled @2 :Bool;  # bits[17, 18)
  mockEngaged @3 :Bool;  # bits[18, 19)
  enum App @0x9917470acf94d285 {
    home @0;
    music @1;
    nav @2;
    settings @3;
    none @4;
  }
}
struct Joystick @0xe42401658e2715e2 {  # 0 bytes, 2 ptrs
  axes @0 :List(Float32);  # ptr[0]
  buttons @1 :List(Bool);  # ptr[1]
}
struct OrbOdometry @0xd7700859ed1f5b76 {  # 32 bytes, 2 ptrs
  startMonoTime @0 :UInt64;  # bits[0, 64)
  endMonoTime @1 :UInt64;  # bits[64, 128)
  f @2 :List(Float64);  # ptr[0]
  err @3 :Float64;  # bits[128, 192)
  inliers @4 :Int32;  # bits[192, 224)
  matches @5 :List(Int16);  # ptr[1]
}
struct OrbFeatures @0xcd60164a8a0159ef {  # 16 bytes, 5 ptrs
  timestampEof @0 :UInt64;  # bits[0, 64)
  xs @1 :List(Float32);  # ptr[0]
  ys @2 :List(Float32);  # ptr[1]
  descriptors @3 :Data;  # ptr[2]
  octaves @4 :List(Int8);  # ptr[3]
  timestampLastEof @5 :UInt64;  # bits[64, 128)
  matches @6 :List(Int16);  # ptr[4]
}
struct OrbFeaturesSummary @0xd500d30c5803fa4f {  # 32 bytes, 0 ptrs
  timestampEof @0 :UInt64;  # bits[0, 64)
  timestampLastEof @1 :UInt64;  # bits[64, 128)
  featureCount @2 :UInt16;  # bits[128, 144)
  matchCount @3 :UInt16;  # bits[144, 160)
  computeNs @4 :UInt64;  # bits[192, 256)
}
struct OrbKeyFrame @0xc8233c0345e27e24 {  # 8 bytes, 3 ptrs
  id @0 :UInt64;  # bits[0, 64)
  pos @1 :ECEFPoint;  # ptr[0]
  dpos @2 :List(ECEFPoint);  # ptr[1]
  descriptors @3 :Data;  # ptr[2]
}
struct DriverState @0xb83c6cc593ed0a00 {  # 64 bytes, 6 ptrs
  frameId @0 :UInt32;  # bits[0, 32)
  modelExecutionTime @14 :Float32;  # bits[288, 320)
  dspExecutionTime @16 :Float32;  # bits[320, 352)
  rawPred @15 :Data;  # ptr[5]
  descriptorDEPRECATED @1 :List(Float32);  # ptr[0]
  stdDEPRECATED @2 :Float32;  # bits[32, 64)
  faceOrientation @3 :List(Float32);  # ptr[1]
  facePosition @4 :List(Float32);  # ptr[2]
  faceProb @5 :Float32;  # bits[64, 96)
  leftEyeProb @6 :Float32;  # bits[96, 128)
  rightEyeProb @7 :Float32;  # bits[128, 160)
  leftBlinkProb @8 :Float32;  # bits[160, 192)
  rightBlinkProb @9 :Float32;  # bits[192, 224)
  irPwrDEPRECATED @10 :Float32;  # bits[224, 256)
  faceOrientationStd @11 :List(Float32);  # ptr[3]
  facePositionStd @12 :List(Float32);  # ptr[4]
  sgProb @13 :Float32;  # bits[256, 288)
  poorVision @17 :Float32;  # bits[352, 384)
  partialFace @18 :Float32;  # bits[384, 416)
  distractedPose @19 :Float32;  # bits[416, 448)
  distractedEyes @20 :Float32;  # bits[448, 480)
}
struct DMonitoringState @0xb83cda094a1da284 {  # 40 bytes, 1 ptrs
  events @0 :List(import "/car.capnp".CarEvent);  # ptr[0]
  faceDetected @1 :Bool;  # bits[0, 1)
  isDistracted @2 :Bool;  # bits[1, 2)
  awarenessStatus @3 :Float32;  # bits[32, 64)
  isRHD @4 :Bool;  # bits[2, 3)
  posePitchOffset @6 :Float32;  # bits[64, 96)
  posePitchValidCount @7 :UInt32;  # bits[96, 128)
  poseYawOffset @8 :Float32;  # bits[128, 160)
  poseYawValidCount @9 :UInt32;  # bits[160, 192)
  stepChange @10 :Float32;  # bits[192, 224)
  awarenessActive @11 :Float32;  # bits[224, 256)
  awarenessPassive @12 :Float32;  # bits[256, 288)
  isLowStd @13 :Bool;  # bits[4, 5)
  hiStdCount @14 :UInt32;  # bits[288, 320)
  isPreview @15 :Bool;  # bits[5, 6)
  isActiveMode @16 :Bool;  # bits[6, 7)
  rhdCheckedDEPRECATED @5 :Bool;  # bits[3, 4)
}
struct Boot @0xa12e8670927a2549 {  # 8 bytes, 3 ptrs
  wallTimeNanos @0 :UInt64;  # bits[0, 64)
  lastKmsg @1 :Data;  # ptr[0]
  lastPmsg @2 :Data;  # ptr[1]
  launchLog @3 :Text;  # ptr[2]
}
struct LiveParametersData @0xd9058dcb967c2753 {  # 32 bytes, 0 ptrs
  valid @0 :Bool;  # bits[0, 1)
  gyroBias @1 :Float32;  # bits[32, 64)
  angleOffset @2 :Float32;  # bits[64, 96)
  angleOffsetAverage @3 :Float32;  # bits[96, 128)
  stiffnessFactor @4 :Float32;  # bits[128, 160)
  steerRatio @5 :Float32;  # bits[160, 192)
  sensorValid @6 :Bool;  # bits[1, 2)
  yawRate @7 :Float32;  # bits[192, 224)
  posenetSpeed @8 :Float32;  # bits[224, 256)
  posenetValid @9 :Bool;  # bits[2, 3)
}
struct LiveMapData @0x9854f620f0d3b9cc {  # 40 bytes, 5 ptrs
  speedLimitValid @0 :Bool;  # bits[0, 1)
  speedLimit @1 :Float32;  # bits[32, 64)
  speedAdvisoryValid @12 :Bool;  # bits[3, 4)
  speedAdvisory @13 :Float32;  # bits[192, 224)
  speedLimitAheadValid @14 :Bool;  # bits[4, 5)
  speedLimitAhead @15 :Float32;  # bits[224, 256)
  speedLimitAheadDistance @16 :Float32;  # bits[256, 288)
  curvatureValid @2 :Bool;  # bits[1, 2)
  curvature @3 :Float32;  # bits[64, 96)
  wayId @4 :UInt64;  # bits[128, 192)
  roadX @5 :List(Float32);  # ptr[0]
  roadY @6 :List(Float32);  # ptr[1]
  lastGps @7 :GpsLocationData;  # ptr[2]
  roadCurvatureX @8 :List(Float32);  # ptr[3]
  roadCurvature @9 :List(Float32);  # ptr[4]
  distToTurn @10 :Float32;  # bits[96, 128)
  mapValid @11 :Bool;  # bits[2, 3)
}
struct CameraOdometry @0xfa9a296b9fd41a96 {  # 16 bytes, 4 ptrs
  frameId @4 :UInt32;  # bits[0, 32)
  timestampEof @5 :UInt64;  # bits[64, 128)
  trans @0 :List(Float32);  # ptr[0]
  rot @1 :List(Float32);  # ptr[1]
  transStd @2 :List(Float32);  # ptr[2]
  rotStd @3 :List(Float32);  # ptr[3]
}
struct KalmanOdometry @0x92e21bb7ea38793a {  # 0 bytes, 4 ptrs
  trans @0 :List(Float32);  # ptr[0]
  rot @1 :List(Float32);  # ptr[1]
  transStd @2 :List(Float32);  # ptr[2]
  rotStd @3 :List(Float32);  # ptr[3]
}
struct Sentinel @0xef0382d244f56e38 {  # 8 bytes, 0 ptrs
  type @0 :SentinelType;  # bits[0, 16)
  enum SentinelType @0xa2d8e61eb6f7031a {
    endOfSegment @0;
    endOfRoute @1;
    startOfSegment @2;
    startOfRoute @3;
  }
}
struct ManagerState @0xcf7154b31a69635b {  # 0 bytes, 1 ptrs
  processes @0 :List(ProcessState);  # ptr[0]
  struct ProcessState @0x869a54d2708469ea {  # 16 bytes, 1 ptrs
    name @0 :Text;  # ptr[0]
    pid @1 :Int32;  # bits[0, 32)
    running @2 :Bool;  # bits[32, 33)
    exitCode @3 :Int32;  # bits[64, 96)
  }
}
struct Event @0xd314cfd957229c11 {  # 16 bytes, 1 ptrs
  logMonoTime @0 :UInt64;  # bits[0, 64)
  valid @67 :Bool = true;  # bits[80, 81)
  union {  # tag bits [64, 80)
    initData @1 :InitData;  # ptr[0], union tag = 0
    frame @2 :FrameData;  # ptr[0], union tag = 1
    gpsNMEA @3 :GPSNMEAData;  # ptr[0], union tag = 2
    sensorEventDEPRECATED @4 :SensorEventData;  # ptr[0], union tag = 3
    can @5 :List(CanData);  # ptr[0], union tag = 4
    thermal @6 :ThermalData;  # ptr[0], union tag = 5
    controlsState @7 :ControlsState;  # ptr[0], union tag = 6
    liveEventDEPRECATED @8 :List(LiveEventData);  # ptr[0], union tag = 7
    model @9 :ModelData;  # ptr[0], union tag = 8
    features @10 :CalibrationFeatures;  # ptr[0], union tag = 9
    sensorEvents @11 :List(SensorEventData);  # ptr[0], union tag = 10
    health @12 :HealthData;  # ptr[0], union tag = 11
    radarState @13 :RadarState;  # ptr[0], union tag = 12
    liveUIDEPRECATED @14 :LiveUI;  # ptr[0], union tag = 13
    encodeIdx @15 :EncodeIndex;  # ptr[0], union tag = 14
    liveTracks @16 :List(LiveTracks);  # ptr[0], union tag = 15
    sendcan @17 :List(CanData);  # ptr[0], union tag = 16
    logMessage @18 :Text;  # ptr[0], union tag = 17
    liveCalibration @19 :LiveCalibrationData;  # ptr[0], union tag = 18
    androidLog @20 :AndroidLogEntry;  # ptr[0], union tag = 19
    gpsLocation @21 :GpsLocationData;  # ptr[0], union tag = 20
    carState @22 :import "/car.capnp".CarState;  # ptr[0], union tag = 21
    carControl @23 :import "/car.capnp".CarControl;  # ptr[0], union tag = 22
    plan @24 :Plan;  # ptr[0], union tag = 23
    liveLocation @25 :LiveLocationData;  # ptr[0], union tag = 24
    ethernetData @26 :List(EthernetPacket);  # ptr[0], union tag = 25
    navUpdate @27 :NavUpdate;  # ptr[0], union tag = 26
    cellInfo @28 :List(CellInfo);  # ptr[0], union tag = 27
    wifiScan @29 :List(WifiScan);  # ptr[0], union tag = 28
    androidGnss @30 :AndroidGnss;  # ptr[0], union tag = 29
    qcomGnss @31 :QcomGnss;  # ptr[0], union tag = 30
    lidarPts @32 :LidarPts;  # ptr[0], union tag = 31
    procLog @33 :ProcLog;  # ptr[0], union tag = 32
    ubloxGnss @34 :UbloxGnss;  # ptr[0], union tag = 33
    clocks @35 :Clocks;  # ptr[0], union tag = 34
    liveMpc @36 :LiveMpcData;  # ptr[0], union tag = 35
    liveLongitudinalMpc @37 :LiveLongitudinalMpcData;  # ptr[0], union tag = 36
    navStatus @38 :NavStatus;  # ptr[0], union tag = 37
    ubloxRaw @39 :Data;  # ptr[0], union tag = 38
    gpsPlannerPoints @40 :GPSPlannerPoints;  # ptr[0], union tag = 39
    gpsPlannerPlan @41 :GPSPlannerPlan;  # ptr[0], union tag = 40
    applanixRaw @42 :Data;  # ptr[0], union tag = 41
    trafficEvents @43 :List(TrafficEvent);  # ptr[0], union tag = 42
    liveLocationTiming @44 :LiveLocationData;  # ptr[0], union tag = 43
    orbslamCorrectionDEPRECATED @45 :OrbslamCorrection;  # ptr[0], union tag = 44
    liveLocationCorrected @46 :LiveLocationData;  # ptr[0], union tag = 45
    orbObservation @47 :List(OrbObservation);  # ptr[0], union tag = 46
    gpsLocationExternal @48 :GpsLocationData;  # ptr[0], union tag = 47
    location @49 :LiveLocationData;  # ptr[0], union tag = 48
    uiNavigationEvent @50 :UiNavigationEvent;  # ptr[0], union tag = 49
    liveLocationKalmanDEPRECATED @51 :LiveLocationData;  # ptr[0], union tag = 50
    testJoystick @52 :Joystick;  # ptr[0], union tag = 51
    orbOdometry @53 :OrbOdometry;  # ptr[0], union tag = 52
    orbFeatures @54 :OrbFeatures;  # ptr[0], union tag = 53
    applanixLocation @55 :LiveLocationData;  # ptr[0], union tag = 54
    orbKeyFrame @56 :OrbKeyFrame;  # ptr[0], union tag = 55
    uiLayoutState @57 :UiLayoutState;  # ptr[0], union tag = 56
    orbFeaturesSummary @58 :OrbFeaturesSummary;  # ptr[0], union tag = 57
    driverState @59 :DriverState;  # ptr[0], union tag = 58
    boot @60 :Boot;  # ptr[0], union tag = 59
    liveParameters @61 :LiveParametersData;  # ptr[0], union tag = 60
    liveMapData @62 :LiveMapData;  # ptr[0], union tag = 61
    cameraOdometry @63 :CameraOdometry;  # ptr[0], union tag = 62
    pathPlan @64 :PathPlan;  # ptr[0], union tag = 63
    kalmanOdometry @65 :KalmanOdometry;  # ptr[0], union tag = 64
    thumbnail @66 :Thumbnail;  # ptr[0], union tag = 65
    carEvents @68 :List(import "/car.capnp".CarEvent);  # ptr[0], union tag = 66
    carParams @69 :import "/car.capnp".CarParams;  # ptr[0], union tag = 67
    frontFrame @70 :FrameData;  # ptr[0], union tag = 68
    dMonitoringState @71 :DMonitoringState;  # ptr[0], union tag = 69
    liveLocationKalman @72 :LiveLocationKalman;  # ptr[0], union tag = 70
    sentinel @73 :Sentinel;  # ptr[0], union tag = 71
    wideFrame @74 :FrameData;  # ptr[0], union tag = 72
    modelV2 @75 :ModelDataV2;  # ptr[0], union tag = 73
    frontEncodeIdx @76 :EncodeIndex;  # ptr[0], union tag = 74
    wideEncodeIdx @77 :EncodeIndex;  # ptr[0], union tag = 75
    managerState @78 :ManagerState;  # ptr[0], union tag = 76
  }
}
